<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="#" />
    <title>dawn</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: rgb(13, 13, 32);
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas tabindex="1" id="gameCanvas"></canvas>
<script type="module">

/////////////
// CLASSES //
/////////////

const Constants = {
    MOVE: {
        APPROACH: 0,
        ORBIT: 1
    },
    ORES: {
        Iron: 0,
        Ice: 1,
        Silicon: 2,
        Gold: 3,
        Titanium:4
    },
    SPRITE: {
        // icons
        MINE: 0,
        PILOT: 1,
        SHIP: 2,
        FIRE: 3,
        FLY_TO: 4,
        ORBIT: 5,
        APPROACH: 6,
        SETTINGS: 7,
        WARP: 8,
        // models
        ASTEROID: 9,
        SPACESHIP: 10
    }
};

class Server {
    constructor() { 
        const ws = new WebSocket('ws://localhost:8080');

        ws.onopen = () => {
            console.log('Connected to server');
        ws.send('Hello, Server!');
        };

        ws.onmessage = (event) => {
            console.log(`Message from server: ${event.data}`);
        };

        ws.onclose = () => {
            console.log('Connection closed');
        };
     }
    
    loadPlayer = () => {
        const dto = new PlayerDTO();
        dto.name = 'Bob';
        dto.credits = 0;
        dto.docked = false;
        return new Player(dto);
    };

    loadSpaceship = () => {
        const dto = new SpaceshipDTO();
        dto.type = 'frigate';
        dto.shield = 50;
        dto.maxShield = 80;
        dto.hull = 30;
        dto.maxHull = 50;
        dto.size = 15;
        dto.acceleration = 0.005;
        dto.vel = 0; //new Vec(0, 0); // FAKING IT
        dto.pos = new Vec(canvas.width / 2, canvas.height / 2);
        dto.target = dto.pos.clone();
        dto.miningRange = 50;
        dto.mode = Constants.MOVE.APPROACH;
        dto.modules = [new Module('laser weapon', Constants.SPRITE.FIRE, 1, 'module'),
                        new Module('mining laser', Constants.SPRITE.MINE, 1, 'module'),
                        new Module('warp drive', Constants.SPRITE.WARP, 1, 'module')]
        dto.inventory = [];
        return new Spaceship(dto);
    };
}

class PlayerDTO {
    constructor() {}
    name = undefined; // string
    credits = undefined; // number
    docked = undefined; // boolean
}

class Player extends PlayerDTO {
    constructor(dto) {
        super();
        Object.assign(this, dto);
    }

    update = (delta) => {
        return this;
    };

    draw = () => { };
}

class Enemy {
    constructor() { }

    pos = new Vec(Math.random() * canvas.width, Math.random() * canvas.height);
    vel = new Vec(Math.random() * 0.01 - 0.005, Math.random() * 0.01 - 0.005);
    
    update = (delta) => {
        return this;
    };

    draw = () => { };
}

class Station {
    constructor (name, pos, type = 'trading') {
        this.name = name;
        this.pos = pos;
        this.type = type;
    }
    dockingRadius = 100;
    inventory = [];
    prices = {
        // TODO: use the actual ore types instead from Constants
        buy: {
            [Constants.ORES.Iron]: 50,
            [Constants.ORES.Ice]: 100,
            [Constants.ORES.Silicon]: 150,
            [Constants.ORES.Gold]: 200,
            [Constants.ORES.Titanium]: 300
        },
        sell: {
            [Constants.ORES.Iron]: 50/2,
            [Constants.ORES.Ice]: 100/2,
            [Constants.ORES.Silicon]: 150/2,
            [Constants.ORES.Gold]: 200/2,
            [Constants.ORES.Titanium]: 300/2

        }
    };

    draw = () => {
        if(player.docked) {
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('YOU ARE DOCKED~! this is the statino UI!', this.pos.x, this.pos.y - 45);
            return;
        }
        ctx.save();
        // Draw station
        ctx.fillStyle = 'rgba(150, 150, 200, 1)';
        ctx.strokeStyle = 'rgba(200, 200, 255, 0.8)';
        ctx.lineWidth = 2;
        // Main body
        ctx.beginPath();
        ctx.rect(this.pos.x - 30, this.pos.y - 30, 60, 60);
        ctx.fill();
        ctx.stroke();
        // Docking area indicator
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.dockingRadius, 0, Math.PI * 2);
        ctx.stroke();
        // Station name
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.name, this.pos.x, this.pos.y - 45);
        ctx.restore();
    };

    canDock = () => this.pos.sub(spaceship.pos).length() < this.dockingRadius;

    buyFromShip = (itemName, quantity, ship) => {
        const price = this.prices.buy[itemName];
        if (!price) return false;
        const item = ship.inventory.find(i => i.name === itemName);
        if (!item || item.quantity < quantity) return false;

        const totalPrice = price * quantity;
        
        // Transfer items and credits
        item.quantity -= quantity;
        ship.credits += totalPrice;
        
        // Remove item if quantity is 0
        if (item.quantity <= 0) {
            const index = ship.inventory.indexOf(item);
            ship.inventory.splice(index, 1);
        }
        
        return true;
    };

    sellToShip = (itemName, quantity, ship) => {
        const price = this.prices.sell[itemName];
        if (!price) return false;

        const totalPrice = price * quantity;
        if (ship.credits < totalPrice) return false;

        // Transfer items and credits
        ship.addToInventory(itemName, quantity);
        ship.credits -= totalPrice;
        
        return true;
    };
}

class StationManager {
    constructor() {
        this.stations = [];
        this.stations.push(
            new Station('Alpha Station', new Vec(500, 500), 'trading'),
            new Station('Beta Mining', new Vec(-500, -500), 'mining'),
            new Station('Gamma Port', new Vec(-500, 500), 'trading'),
            new Station('Delta Hub', new Vec(500, -500), 'trading')
        );
    }

    update = () => {
        // TODO: filter instead of if
        this.stations.forEach(station => {
            if (station.canDock()) {
                // Show docking indicator or enable docking menu
                this.showDockingPrompt(station);
            }
        });
        return this;
    };

    draw = (ctx) => {
        this.stations.forEach(station => station.draw(ctx));
    };

    // Draw docking prompt when ship is in range
    showDockingPrompt = (station) => {   
        ctx.save();
        ctx.fillStyle = 'grey';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Press F to ${player.docked ? 'UN-' : ''}dock`, 
                    station.pos.x, 
                    station.pos.y - 60);
        ctx.restore();
    };

    handleDocking = () => {
        if (player.docked) {
            player.docked = false;
            return;
        }
        if (this.stations.find(s => s.canDock())) {
            player.docked = true;
        }
    };
}

class Mission {
    constructor(title, description, reward) {
        this.title = title;
        this.description = description;
        this.reward = reward;
        this.completed = false;
        this.active = false;
    }

    start = () => {
        this.active = true;
    };

    complete = () => {
        this.completed = true;
        this.active = false;
        player.credits += this.reward;
    };

    update = (delta) => {
        // Override in subclasses
    };
}

class DeliveryMission extends Mission {
    constructor(station, requiredOre, amount, reward) {
        const title = `Deliver ${amount} ${requiredOre}`;
        const description = `Deliver ${amount} units of ${requiredOre} to ${station.name}`;
        super(title, description, reward);
        this.station = station;
        this.requiredOre = requiredOre;
        this.requiredAmount = amount;
        this.deliveredAmount = 0;
    }
    
    update = () => {
        if (!this.active || this.completed) return;
        // Check if ship is close enough to station
        const distance = spaceship.pos.sub(this.station.pos).length();
        if (distance < this.station.dockingRadius) {
            // Check ship's cargo for required ore
            const cargo = spaceship.inventory.find(item => item.type === 'ore' && 
                                                    item.name === this.requiredOre);
            if (cargo) {
                const amountToTransfer = Math.min(
                    cargo.quantity, 
                    this.requiredAmount - this.deliveredAmount
                );
                // Transfer ore from ship to station
                cargo.quantity -= amountToTransfer;
                this.deliveredAmount += amountToTransfer;
                // Remove cargo item if empty
                if (cargo.quantity <= 0) {
                    const index = spaceship.inventory.indexOf(cargo);
                    spaceship.inventory.splice(index, 1);
                }
                // Check if mission is complete
                if (this.deliveredAmount >= this.requiredAmount) {
                    this.complete();
                }
            }
        }
    };
}

class MissionManager {
    constructor() {

        this.availableMissions = [];
        this.activeMissions = [];
        this.completedMissions = [];
    }

    generateNewMissions = () => {
        // Generate some random delivery missions
        stationManager.stations.forEach(station => {
            if (Math.random() < 0.3) {  // 30% chance per station
                const ores = Object.keys(Constants.ORES);
                const ore = ores[Math.floor(Math.random() * ores.length)];
                const amount = Math.floor(Math.random() * 10) + 5;  // 5-15 units
                const reward = amount * (ore === 'Gold' ? 100 : ore === 'Copper' ? 50 : 25);
                const mission = new DeliveryMission(station, ore, amount, reward);
                this.availableMissions.push(mission);
            }
        });
    };

    // TODO: any missions can be accepted at any stations for now...
    acceptMission = () => {
        if (this.availableMissions.length === 0) return;
        const mission = this.availableMissions[0];
        this.activeMissions.push(mission);
        this.availableMissions.splice(0, 1);
        mission.start();
    };

    update = (delta) => {
        this.activeMissions.forEach(mission => {
            mission.update(delta);
            if (mission.completed) {
                const index = this.activeMissions.indexOf(mission);
                this.activeMissions.splice(index, 1);
                this.completedMissions.push(mission);
            }
        });
        return this;
    };

    draw = (x = 10, y = 110, width = 300) => {
        // Draw mission UI
        // TODO: should probably be conditional
        ctx.save();
        
        // Draw panel background
        ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
        ui.roundedRectExt(ctx, x, y, width, 400, 10);
        
        // Draw title
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('Missions', x + 20, y + 30);

        if (player.docked) {
            ctx.fillText('(M to accept missions)', x + 110, y + 30);
        }
            
        // Draw active missions
        let yOffset = y + 60;
        ctx.font = '12px Arial';
        
        if (this.activeMissions.length === 0) {
            ctx.fillText('No active missions', x + 20, yOffset);
        } else {
            this.activeMissions.forEach(mission => {
                ctx.fillStyle = 'rgba(100, 255, 100, 0.8)';
                ctx.fillText(mission.title, x + 20, yOffset);
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.fillText(mission.description, x + 20, yOffset + 20);
                ctx.fillText(`Reward: ${mission.reward} credits`, x + 20, yOffset + 40);
                yOffset += 70;
            });
        }
        ctx.restore();
    };
}

class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }

    update = () => {
        this.x = canvas.width/2 - spaceship.pos.x;
        this.y = canvas.height/2 - spaceship.pos.y;
    };

    apply = () => {
        ctx.save();
        ctx.translate(this.x, this.y);
    };

    restore = () => {
        ctx.restore();
    };

    screenToWorld = (screenX, screenY) => {
        return new Vec(screenX - this.x, screenY - this.y);
    };
}

class AsteroidField {
    constructor() {
        this.maxAsteroids = 5;
        this.asteroids = [];
    }

    update = (delta) => {
        if (this.asteroids.length < this.maxAsteroids) {
            this.asteroids.push(new Asteroid().moveAway());
        }
        this.asteroids.forEach(a => a.update(delta));
        return this;
    };

    draw = () => {
        if(player.docked) return;
        this.asteroids.forEach(a => a.draw());
    };
}

class Asteroid {
    constructor() {
        this.size = Math.random() * 20 + 30;
        this.pos = new Vec(Math.random() * (canvas.width-40) + 20, 
                           Math.random() * (canvas.height-40) + 20);
        this.rotationSpeed = Math.random() * 0.0008;
        this.rotation = Math.random() * Math.PI * 2;
        this.selected = false;
    }

    moveAway = () => {
        // TODO: check if the asteroid is too close to another asteroid
        // if so, move it away
        // also, check if the asteroid is too close to the player
        // if so, move it away
        // also, check if the asteroid is too close to the spaceship
        // if so, move it away
        // also, check if the asteroid is too close to the station
        // if so, move it away
        return this;
    };

    mine = () => {
        if (Math.random() < 0.5) { // 1 ore
            const amount = this.size * (1 + Math.random() * 0.2);
            return [{ type: this.randomOre(), amount }];
        } // 2 ores
        const amount = this.size * (1 + Math.random() * 0.2);
        const distribution = (Math.random()*60+20) / 100; // 20-80%
        return [{ type: this.randomOre(), amount: amount * distribution },
                { type: this.randomOre(), amount: amount * (1-distribution) }];
    }

    update = (delta) => {
        const rotation = this.rotation + this.rotationSpeed * delta;
        const clampedRotation = rotation % (Math.PI * 2);
        this.rotation = clampedRotation;
    };

    draw = () => {
        ui.drawIcon(Constants.SPRITE.ASTEROID, this.pos, false,
            asteroidField.asteroids.indexOf(this), false, 2, this.rotation);
        if (this.selected) {
            // TODO: wrong line styling...
            ctx.setLineDash([10, 5]);
            ctx.fillStyle = 'green';
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            ctx.rect(this.pos.x - this.size, this.pos.y - this.size, this.size * 2, this.size * 2);
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('Asteroid size ' + this.size.toFixed(1), 
                            this.pos.x - this.size, this.pos.y - this.size - 10);
        }
    };

    randomOre = () => {
        const oreTypes = Object.keys(Constants.ORES).length;
        const randomIndex = Math.floor(Math.random() * oreTypes);
        return Object.keys(Constants.ORES)[randomIndex];
    }
}

class SpaceshipDTO {
    constructor() {
        this.type = undefined; // string
        this.shield = undefined; // number
        this.maxShield = undefined; // number
        this.hull = undefined; // number
        this.maxHull = undefined; // number
        this.size = undefined; // number
        this.acceleration = undefined; // number
        this.vel = undefined; // Vec
        this.pos = undefined; // Vec
        this.target = undefined; // Vec
        this.miningRange = undefined; // number
        this.mode = undefined; // Constants.MOVE
        this.modules = undefined; // Module[]
        this.inventory = undefined; // Module[]
    }
}

class Spaceship extends SpaceshipDTO {
    constructor(dto) {
        super();
        Object.assign(this, dto);
    }

    update = (delta) => {
        this.move(delta);
        if (ui.k2down) this.mine();
        return this;
    };

    draw = () => {
        if(player.docked) return;
        ctx.save();
        // position correctly
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle + Math.PI/2.0);
        ctx.translate(-this.size*1.5, -this.size*1.5);
        // draw ship
        ui.drawIcon(Constants.SPRITE.SPACESHIP, { x: 0, y: 0 }, false, undefined, false, 1);
        // draw vector
        ctx.translate(this.size * 1.5, 0);
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.strokeStyle = 'lightblue';
        ctx.moveTo(0, 0);
        const speed = this.vel; //.length();
        ctx.lineTo(0, -speed * 10);
        ctx.stroke();
        ctx.restore();
        ctx.lineWidth = 1;
    };

    move = (delta) => {
        if (this.mode === Constants.MOVE.APPROACH) {
            const dir = this.target.sub(this.pos);
            if (dir.length() > this.size) {
                const normalizedDir = dir.normalize();
                // REAL PHYSICS
                // const scaledDir = normalizedDir.scale(this.acceleration * delta);
                // const slow = scaledDir.clone().scale(-0.5);
                // this.vel = this.vel.add(scaledDir);
                // this.pos = this.pos.add(slow).add(this.vel);
                // this.angle = Math.atan2(this.vel.y, this.vel.x);

                // FAKE PHYSICS
                this.vel += this.acceleration * delta;
                this.pos = this.pos.add(normalizedDir.scale(this.vel));
                this.angle = Math.atan2(normalizedDir.y, normalizedDir.x);
            } else {
                this.vel = 0; //.set(0, 0);
            };

        } else if (this.mode === Constants.MOVE.ORBIT) {
            // implment orbit mode here     
        }
    };

    mine = () => {
        // TODO: find() instead of forEach()
        // so ores.forEach is not nested
        // and so that you only mine one asteroid at a time
        asteroidField.asteroids.forEach((a, i) => {
            const dist = this.pos.sub(a.pos).length();
            const range = this.miningRange + a.size;
            if (dist > range) return;
            asteroidField.asteroids.splice(i, 1);
            const ores = a.mine(); // [{ type, amount }, ...]
            ores.forEach(ore => {
                const oreModule = this.inventory.find(m => m.name === ore.type);
                if (oreModule) {
                    oreModule.amount += ore.amount;
                } else {
                    this.inventory.push(new Module(ore.type, Constants.SPRITE.MINE, ore.amount, 'kg'));
                }
            });  
        });
    };
}

class Module {
    constructor(name, sprite = undefined, amount = 1, unit = 'units') {
        this.name = name;
        this.sprite = sprite;
        this.amount = amount;
        this.unit = unit;
    }
}

class StarField {
    constructor() {
        this.stars = [];
        const createStarLayer = (count, speed, brightness) => {
            for (let i = 0; i < count; i++) {
                this.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,  // Size between 1-3
                    speed,
                    brightness
                });

            }
        };
        createStarLayer(100, 0.1, 0.2),  // Far layer (slow, dim)
        createStarLayer(50, 0.15, 0.4),   // Middle layer
        createStarLayer(25, 0.2, 0.6)   // Close layer (fast, bright)
    }

    update = (delta) => {
        this.stars.forEach(star => {
            // Move stars based on their layer speed
            star.x -= star.speed;
            star.y -= star.speed;
            // Wrap stars around the screen
            if (star.x < 0) star.x = canvas.width;
            if (star.x > canvas.width) star.x = 0;
            if (star.y < 0) star.y = canvas.height;
            if (star.y > canvas.height) star.y = 0;
        });
        return this;
    };
    
    draw = () => {
        if(player.docked) return;
        this.stars.forEach(star => {
            ctx.beginPath();
            ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();

        });
    };
}

class UI {
    constructor() {
        this.fpsCount = 0;
        this.fpsTime = 0;
        this.fpsDisplay = 0;
        this.qDown = false;
        this.aDown = false;
        this.sDown = false;
        this.wDown = false;
        this.k1down = false;
        this.k2down = false;
        this.k3down = false;

        // TODO: why can I declare fields with and without this?
        // does that mean one is public and the other private?
        this.dialogWidth = 300;
        this.dialogHeight = 400;
        this.dialogX = canvas.width / 2 - this.dialogWidth / 2;
        this.dialogY = canvas.height / 2 - this.dialogHeight / 2;

        this.sprites = [];
        this.loadSprites();
    }

    update = (delta) => {
        this.fpsCount++;
        this.fpsTime += delta;
        if (this.fpsTime >= 1000) {

            this.fpsDisplay = this.fpsCount;
            this.fpsCount = 0;
            this.fpsTime = 0;
        }
        return this;
    };

    draw = () => {
        if (this.wDown) {
            this.drawShipDialog();
        } else if (this.eDown) {
            this.drawPilotDialog();
        } else if (this.dDown) {
            this.drawSettingsDialog();
        } else if (this.k1down) {
            this.drawWarpDialog();
        }
        this.drawFps();
        this.drawButtons();
    };

    drawIcon = (spriteIndex, pos, selected = false, text = undefined, 
                     outline = true, scale = 1, rotation = 0) => {
        const size = 40*scale;
        if (!this.sprites[spriteIndex]) return;
        if (selected) ctx.globalAlpha = 0.5;
        if (rotation !== 0) {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(rotation);
            ctx.drawImage(this.sprites[spriteIndex], -size/2, -size/2, size, size);
            ctx.restore();

        } else {
            ctx.drawImage(this.sprites[spriteIndex], pos.x, pos.y, size, size);
        }
        if (outline) {
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.strokeRect(pos.x, pos.y, 40, 40);
        }
        if (text !== undefined) {
            ctx.font = '11px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(text, pos.x+1, pos.y+5);
            ctx.fillText(text, pos.x-1, pos.y+4);
            ctx.fillStyle = 'white';
            ctx.fillText(text, pos.x, pos.y+4);
        }
        ctx.globalAlpha = 1;
    };

    roundedRectExt = (x, y, width, height, radius) => {
        this.roundedRect(x, y, width, height, radius);
    }

    roundedRect = (x, y, width, height, radius) => {
        ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    };

    loadSprites = () => {
        const spriteSheet = new Image();
        // icons from:
        // https://game-icons.net/
        // https://icons8.com
        spriteSheet.src = 'icons.png';
        spriteSheet.onload = () => {
            const spriteWidth = 40;
            const spriteHeight = 40;
            const columns = spriteSheet.width / spriteWidth;
            const rows = spriteSheet.height / spriteHeight;
            
            // Create a temporary canvas to extract sprites
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = spriteWidth;
            tempCanvas.height = spriteHeight;

            // Extract each sprite
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns; col++) {
                    tempCtx.clearRect(0, 0, spriteWidth, spriteHeight);

                    // Draw the portion of the sprite sheet we want
                    tempCtx.drawImage(
                        spriteSheet,
                        col * spriteWidth,    // source x
                        row * spriteHeight,   // source y
                        spriteWidth,          // source width
                        spriteHeight,         // source height
                        0,                    // dest x
                        0,                    // dest y
                        spriteWidth,          // dest width
                        spriteHeight          // dest height
                    );
                    
                    // Convert to an image and store
                    const sprite = new Image();
                    sprite.src = tempCanvas.toDataURL();
                    this.sprites.push(sprite);
                }
            }
        };
    }

    drawWarpDialog = () => {
        console.log('drawWarpDialog');
    };

    drawPanel = (pos, w, h) => {
        ctx.setLineDash([]);
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(pos.x, pos.y, w, h);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(pos.x, pos.y, w, h);
    };

    drawTexts = (texts, pos, off = 30, hor = false, 
                 selected = -1, color = 'white') => {
        let lastLength = 0
        texts.forEach((text, i) => {
            const x = pos.x + (hor ? off * i + lastLength * 8 : 0);
            const y = pos.y + (hor ? 0 : off * i);
            if (i === selected) ctx.fillStyle = 'blue';
            else ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(text, x, y);
            lastLength += text.length;
        });
    };

    drawFps = () => {
        this.drawPanel({ x: 0, y: 0 }, 100, 50);
        this.drawTexts(['fps: ' + this.fpsDisplay], { x: 10, y: 30 });
    };

    drawHealthCircle = (radius, percentage, color) => {
        const thickness = 8;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
        ctx.lineWidth = thickness;
        ctx.arc(canvas.width / 2, canvas.height - 60, radius, 0, Math.PI * 2);
        ctx.stroke();
        if (percentage > 0) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            const startAngle = -0.5 * Math.PI;
            const endAngle = (-0.5 + 2 * percentage / 100) * Math.PI;
            ctx.arc(canvas.width / 2, canvas.height - 60, radius, startAngle, endAngle);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
    };

    // TODO: simplify and re-use code for the UI - there's too much
    // and it's too complicated
    drawButtons = () => {
        const shieldPercentage = spaceship.shield / spaceship.maxShield * 100;
        const hullPercentage = spaceship.hull / spaceship.maxHull * 100;
        this.drawHealthCircle(40, shieldPercentage, 'rgba(0, 150, 255, 0.8)');
        this.drawHealthCircle(30, hullPercentage, 'rgba(255, 150, 0, 0.8)');
        this.drawTexts(['shield', `${shieldPercentage}%`],
                    { x: canvas.width / 2 - 90, y: canvas.height - 80 }, 15);
        this.drawTexts(['hull', `${hullPercentage}%`], 
                    { x: canvas.width / 2 + 60, y: canvas.height - 80 }, 15);
        const off = 45;
        let i = 3;
        const i2pos = (i) => { return { x: canvas.width / 2 - off*i, y: canvas.height - 45}; };
        this.drawIcon(Constants.SPRITE.FLY_TO, i2pos(i++), this.qDown, 'Q');
        this.drawIcon(Constants.SPRITE.APPROACH, i2pos(i++), this.aDown, 'A');
        this.drawIcon(Constants.SPRITE.ORBIT, i2pos(i++), this.sDown, 'S');
        this.drawIcon(Constants.SPRITE.SHIP, i2pos(i++), this.wDown, 'W');
        this.drawIcon(Constants.SPRITE.PILOT, i2pos(i++), this.eDown, 'E');
        this.drawIcon(Constants.SPRITE.SETTINGS, i2pos(i++), this.dDown, 'D');
        i = -4;
        this.drawIcon(Constants.SPRITE.FIRE, i2pos(i++), this.k3down, '3');
        this.drawIcon(Constants.SPRITE.MINE, i2pos(i++), this.k2down, '2');
        this.drawIcon(Constants.SPRITE.WARP, i2pos(i++), this.k1down, '1');
    };

    drawPilotDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Pilot', this.dialogWidth, yOffset, this.dialogX);
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        ctx.fillText(`name: ${player.name}`, this.dialogX + 30, yOffset += 20);
        ctx.fillText(`name: ${player.name}`, this.dialogX + 30, yOffset += 20);
        ctx.fillText(`credits: ${player.credits}`, this.dialogX + 30, yOffset += 20);
    };

    drawSettingsDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Settings', this.dialogWidth, yOffset, this.dialogX);
        yOffset += 20;
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        ctx.fillText('Exit Now', this.dialogX + 30, yOffset);
    };

    drawShipDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Equipped Modules', this.dialogWidth, yOffset, this.dialogX);
        yOffset = this.drawSectionItems(spaceship.modules, yOffset, this.dialogX);
        yOffset = this.drawSectionHeader('Inventory', this.dialogWidth, yOffset, this.dialogX);
        this.drawSectionItems(spaceship.inventory, yOffset, this.dialogX);
    };

    drawSectionHeader = (text, width, yOffset, x) => {
        yOffset += 20;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial';
        ctx.fillText(text, x + 20, yOffset += 20);
        ctx.beginPath();

        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
        ctx.moveTo(x + 10, yOffset += 20);
        ctx.lineTo(x + width - 10, yOffset);
        ctx.stroke();
        ctx.font = '14px Arial';
        return yOffset + 20;
    };

    drawSectionItems = (modules, yOffset, x) => {
        modules.forEach((module) => {
            const m = module;
            ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
            ctx.fillText(`${module.name}`, x + 30, yOffset);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
            const amount = module.amount > 1 ? module.amount.toFixed(2) : module.amount;
            ctx.fillText(`${amount} ${module.unit}`, x + 150, yOffset);
            yOffset += 20;
        });
        return yOffset;
    };
}

class GameEventListener {
    register = () => {
        canvas.addEventListener('keyup', this.keyUpListener);
        canvas.addEventListener('keydown', this.keyDownListener);
        canvas.addEventListener('click', this.clickListener);
    };

    keyUpListener = (event) => {
        if (event.key === 'q') {
            ui.qDown = false;
        } else if (event.key === 'a') {
            ui.aDown = false;
        } else if (event.key === 's') {
            ui.sDown = false;
        } else if (event.key === '1') {
            ui.k1down = false;
        } else if (event.key === '2') {
            ui.k2down = false;
        } else if (event.key === '3') {
            ui.k3down = false;
        } else if (event.key === 'w') {
            ui.wDown = false;
        } else if (event.key === 'e') {
            ui.eDown = false;
        } else if (event.key === 'd') {
            ui.dDown = false;
        }
    };

    keyDownListener = (event) => {
        // TODO: allow selection stations as well - but only one at a time
        // do this in a super? Selectable class?
        // maybe get cursor to suggest something.
        const selected = asteroidField.asteroids.find(a => a.selected);
        // MENUS
        if (event.key === 'w') {
            ui.wDown = true;
        } else if (event.key === 'e') {
            ui.eDown = true;
        } else if (event.key === 'd') {
            ui.dDown = true;
        } else if (event.key === 'f') {
            stationManager.handleDocking();
        } else if (event.key === 'm' && player.docked) {
            missionManager.acceptMission();
        } 

        if (player.docked) return
        
        // MOVEMENT
        if (event.key === 'q') {
            if (ui.qDown) return;
            ui.qDown = true;
        } else if (event.key === 'a') {
            ui.aDown = true;
            if (selected) {
                spaceship.mode = Constants.MOVE.APPROACH;
                spaceship.target = selected.pos;
            } else {
                console.log('no asteroid selected');
            }
        } else if (event.key === 's') {
            ui.sDown = true;
            if (selected) {
                spaceship.mode = Constants.MOVE.ORBIT;
                spaceship.target = selected.pos;
            } else {
                console.log('no asteroid selected');
            }
        }
        
        // MODULES
        if (event.key === '1') {
            ui.k1down = true;
        } else if (event.key === '2') {
            ui.k2down = true;
        } else if (event.key === '3') {
            ui.k3down = true;
        }
    };

    clickListener = (event) => {
        let select = undefined;
        const clickPos = camera.screenToWorld(event.x, event.y);
        // fly-to
        if (ui.qDown) { 
            spaceship.target = clickPos;
            return;
        }
        // select asteroid
        asteroidField.asteroids.forEach((a) => {
            const dist = clickPos.sub(a.pos).length();
            if (dist < a.size) {
                select = a;
            }
        });
        // de-select asteroids
        if (select) {
            asteroidField.asteroids.forEach((a) => { a.selected = false; });
            select.selected = true;
        }
    };
}

class Vec {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    add = (v) => {
        return new Vec(
            this.x + v.x,
            this.y + v.y,
        );
    };

    sub = (v) => {
        return new Vec(
            this.x - v.x,
            this.y - v.y,
        );
    };

    scale = (n) => {
        return new Vec(
            this.x * n,
            this.y * n,
        );
    };

    length = () => {
        return Math.sqrt(
            this.x * this.x +
            this.y * this.y
        );
    };

    normalize = () => {
        const len = this.length();
        if (len === 0) return new Vec();
        return this.scale(1 / len);
    };

    dot = (v) => {
        return this.x * v.x + this.y * v.y;
    };

    cross = (v) => {
        return this.x * v.y - this.y * v.x;
    };

    toString = () => {
        return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
    };

    clone = () => {
        return new Vec(this.x, this.y);
    };

    set = (x, y) => {
        this.x = x;
        this.y = y;
    };
}

class Game {
    constructor() {
        this.lastDelta = 0;
    }

    gameLoop = (delta) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const newDelta = delta - this.lastDelta;
        this.lastDelta = delta;
        starField.update(newDelta).draw();

        // start camera transformation
        camera.update();
        camera.apply();
        stationManager.update(newDelta).draw();
        asteroidField.update(newDelta).draw();
        spaceship.update(newDelta).draw();
        // stop transformation
        camera.restore();

        missionManager.update(newDelta).draw();
        player.update(newDelta).draw();
        ui.update(newDelta).draw();

        requestAnimationFrame(this.gameLoop);
    };

    start = () => {
        // register event listeners
        new GameEventListener().register();

        // generate missions
        setInterval(() => {
            if (player.docked) return;
            missionManager.generateNewMissions();
        }, 3000);

        // start game loop
        requestAnimationFrame(this.gameLoop);
    };
}

////////////
// FIELDS //
////////////

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const server = new Server();
const starField = new StarField();
const asteroidField = new AsteroidField();
const player = server.loadPlayer();
const spaceship = server.loadSpaceship();
const ui = new UI();
const camera = new Camera();
const missionManager = new MissionManager();
const stationManager = new StationManager();
new Game().start();

</script>
</body>
</html>

<!-- notes

first mission. given a frigate.
we're under attack. please help.
take out this frigate by locking them up, flying to them, and firing your guns.

second mission: our buddies need help too.
kill three frigates. these frigates are equipped with short range weapons.
stay out of range of their weapons while just staying in range of yours.
kite as necessary and take them down.

third mission. it doesn't seem like there any way out of this alive.
too many ships are warping in and our ward drive is down.
let's go do fighting. after all, a good fight is what it's all about.

welcome back pilot. you have awoken in another clone.
here's how a station works. you have been given a new frigate and 
a choice between weapons. a few more fighting missions follow
explaining more mechanics and dropping some cool loot.

then comes crafting. there are 2 aspects. mining and manufactoring.
levels are trained in both.
as you kill and loot and sell, you get xp and credits.
xp has some inherent bonuses to the skills you level
and credits can be used to buy ships and components.
credits carry over between deaths.

keep ship in the middle and move the screen instead.

move all the node.children logic into class initializer.

controls:
D = warp
some UI for warping?
no gates. space is small instances that you can warp between.
usually at planets, moons, or structures in space.
display these buttons as squares in UI.

ressing the button should show the button being pressed
by slowly highliting it.
make the UI nicer. see through layer

-->