<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="#" />
    <title>dawn</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: rgb(13, 13, 32);
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas tabindex="1" id="gameCanvas"></canvas>
<script type="module">

/////////////
// CLASSES //
/////////////

const Constants = {
    MOVE: {
        APPROACH: 0,
        ORBIT: 1
    },
    ORES: {
        Iron: 0,
        Ice: 1,
        Silicon: 2,
        Gold: 3,
        Titanium:4
    },
    SPRITE: {
        // icons
        MINE: 0,
        PILOT: 1,
        SHIP: 2,
        FIRE: 3,
        FLY_TO: 4,
        ORBIT: 5,
        APPROACH: 6,
        SETTINGS: 7,
        WARP: 8,
        // models
        ASTEROID: 9,
        SPACESHIP: 10
    },
    COLOR: {
        RED: '255, 50, 50',
        GREEN: '50, 255, 50',
        BLUE: '50, 50, 255'
    }
};

class Server {
    constructor() { 
        this.loggingIn = false;
        this.ws = new WebSocket('ws://localhost:8080');
        this.ws.onopen = () => {
            console.log('Connected to server');
            this.isConnected = true;
        };

        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log(`Message from server: ${data}`);
            if (data.action === 'login') {
                player = new Player(data.player);
                spaceship = new Spaceship(data.spaceship);
            }
        };

        this.ws.onclose = () => {
            console.log('Connection closed');
        };
    }

    loadSystem = () => {
        // TODO: move logic to server
        const namePrefix = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 
                     'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 
                     'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
        const stationSuffix = ['Station', 'Hub', 'Port', 'Mining', 'Factory', 'Research', 'Academy']; 

        const randomNamePrefix = () => {
            return namePrefix[Math.floor(Math.random() * namePrefix.length)];
        };

        const randomStationSuffix = () => {
            return stationSuffix[Math.floor(Math.random() * stationSuffix.length)];
        };

        const usedSystemNames = [];
        const randomSystemName = () => {  
            let name = `${randomNamePrefix()}-${Math.floor(Math.random() * 9)}`;
            while (usedSystemNames.includes(name)) {
                name = `${randomNamePrefix()}-${Math.floor(Math.random() * 9)}`;
            }
            usedSystemNames.push(name);
            return name;
        };

        const usedStationNames = [];
        const randomStation = () => {
            const pos = new Vec(Math.random() * 600 + 100, Math.random() * 600 + 100);
            let name = `${randomNamePrefix()} ${randomStationSuffix()}`;
            while (usedStationNames.includes(name)) {
                name = `${randomNamePrefix()} ${randomStationSuffix()}`;
            }
            usedStationNames.push(name);
            return new Station(name, pos);
        };

        // create systems
        const A = new System(randomSystemName(), Constants.COLOR.RED, [randomStation()]);    
        const B = new System(randomSystemName(), Constants.COLOR.GREEN, [randomStation()]);
        const C = new System(randomSystemName(), Constants.COLOR.BLUE, [randomStation()]);

        // create connections
        const A_B = {system: B, distance: 100};
        const A_C = {system: C, distance: 200};
        const B_A = {system: A, distance: A_B.distance};
        const C_A = {system: A, distance: A_C.distance};
        A.connections = [A_B, A_C];
        B.connections = [B_A];
        C.connections = [C_A];
        
        return A;
    };

    login = (user, pass) => {
        if (this.ws.readyState !== WebSocket.OPEN) {
            console.log('not connected');
            return;
        }
        this.loggingIn = true;
        const message = {
            action: 'login',
            user,
            pass
        };
        this.ws.send(JSON.stringify(message));
    }
}

class Selectable {
    constructor() {
        ui.selectables.push(this);
        this.size = Math.random() * 20 + 30;
        this.selected = false;
        this.pos = new Vec(Math.random() * (canvas.width-40) + 20, 
                           Math.random() * (canvas.height-40) + 20);
    }

    drawSelection = () => {
        if (this.selected) {
            ctx.strokeStyle = 'rgba(80, 255, 80, 0.5)';
            ctx.setLineDash([10, 5]);
            ctx.fillStyle = 'green';
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            const off = 5;
            ctx.beginPath();
            ctx.moveTo(this.pos.x - this.size - off, this.pos.y - this.size - off);
            ctx.lineTo(this.pos.x + this.size + off, this.pos.y - this.size - off);
            ctx.lineTo(this.pos.x + this.size + off, this.pos.y + this.size + off);
            ctx.lineTo(this.pos.x - this.size - off, this.pos.y + this.size + off);
            ctx.lineTo(this.pos.x - this.size - off, this.pos.y - this.size - off);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}

class Player {
    constructor(obj) {
        this.name = undefined; // string
        this.credits = undefined; // number
        this.docked = undefined; // Station
        Object.assign(this, obj);
    }

    update = (delta) => {
        return this;
    };

    draw = () => { };
}

class Station extends Selectable {
    constructor (name, pos) {
        super();
        this.name = name;
        this.pos = pos;
        this.dockingRadius = 100;
        this.inventory = [];
        this.prices = {
            buy: {
                [Constants.ORES.Iron]: 50,
                [Constants.ORES.Ice]: 100,
                [Constants.ORES.Silicon]: 150,
                [Constants.ORES.Gold]: 200,
                [Constants.ORES.Titanium]: 300
            },
            sell: {
                [Constants.ORES.Iron]: 50/2,
                [Constants.ORES.Ice]: 100/2,
                [Constants.ORES.Silicon]: 150/2,
                [Constants.ORES.Gold]: 200/2,
                [Constants.ORES.Titanium]: 300/2

            }
        };
    }

    draw = () => {
        if (player.docked) return;
        this.drawSelection();
        ctx.save();
        // Draw station
        ctx.fillStyle = 'rgba(150, 150, 200, 1)';
        ctx.strokeStyle = 'rgba(200, 200, 255, 0.8)';
        ctx.lineWidth = 2;
        // Main body
        ctx.beginPath();
        ctx.rect(this.pos.x - 30, this.pos.y - 30, 60, 60);
        ctx.fill();
        ctx.stroke();
        // Docking area indicator
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.dockingRadius, 0, Math.PI * 2);
        ctx.stroke();
        // Station name
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.name, this.pos.x, this.pos.y - 45);
        ctx.restore();
    };

    missionsAtStation = () => {
        return missionManager.availableMissions.filter(m => m.station === this);
    };

    missionToAccept = () => {
        if (!player.docked) return undefined;
        const missions = this.missionsAtStation();
        if (!missions.length) return undefined;
        return missions[0];
    };

    acceptMission = () => {
        const mission = this.missionToAccept();
        if (!mission) return;
        missionManager.activeMissions.push(mission);
        missionManager.availableMissions.splice(0, 1);
        mission.start();
    };

    canDock = () => this.pos.sub(spaceship.pos).length() < this.dockingRadius;
}

// TODO: currently warping between systems
// instead, warp between warpables in system
// and use gates to connect systems
class System {
    constructor(name, color, stations) {
        this.name = name;
        this.color = color;
        this.maxAsteroids = 5;
        this.asteroids = [];
        this.stations = stations;
        this.connections = [];
    }

    update = (delta) => {
        if (this.asteroids.length < this.maxAsteroids) {
            this.asteroids.push(new Asteroid().moveAway());
        }
        this.asteroids.forEach(a => a.update(delta));
        return this;
    };

    draw = (ctx) => {
        this.stations
            .filter(station => station.canDock())
            .forEach(station => {
            // Show docking indicator or enable docking menu
            this.showDockingPrompt(station);
        });
        this.stations.forEach(station => station.draw(ctx));
        if(player.docked) return;
        this.asteroids.forEach(a => a.draw());
    };

    // Draw docking prompt when ship is in range
    showDockingPrompt = (station) => {   
        ctx.save();
        ctx.fillStyle = 'grey';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Press F to dock`, 
                    station.pos.x, 
                    station.pos.y - 60);
        ctx.restore();
    };

    handleDocking = () => {
        if (player.docked) {
            player.docked = undefined;
            return;
        }
        const stationToDock = this.stations.find(s => s.canDock());
        if (stationToDock) {
            player.docked = stationToDock;
        }
    };
}

class Mission {
    constructor(description, station, reward) {
        this.description = description;
        this.station = station;
        this.reward = reward;
        this.completed = false;
        this.active = false;
    }

    start = () => {
        this.active = true;
    };

    completeSuper = () => {
        this.completed = true;
        this.active = false;
        player.credits += this.reward;
    };

    update = (delta) => {

    };
}

// TODO: rename to minig mission
class MiningMission extends Mission {
    constructor(station, requiredOre, amount, reward) {
        const description = `Deliver ${amount} units of ${requiredOre} to ${station.name}`;
        super(description, station, reward);
        this.requiredOre = requiredOre;
        this.amount = amount;
    }

    canComplete = () => {
        return spaceship.inventory
            .find(item => item.name === this.requiredOre && item.amount >= this.amount);
    }

    complete = () => {
        this.completeSuper();
        const cargo = this.canComplete();
        // Transfer ore from ship to station
        cargo.amount -= this.amount;
        // Remove cargo item if empty
        if (cargo.amount <= 0) {
            const index = spaceship.inventory.indexOf(cargo);
            spaceship.inventory.splice(index, 1);
        }
    }
    
    update = (delta) => {

    };
}

class MissionManager {
    constructor() {
        this.availableMissions = [];
        this.activeMissions = [];
        this.completedMissions = [];
    }

    generateNewMissions = () => {
        system.stations
            .filter(station => station.missionsAtStation().length < 3) // max 3 missions per station
            .filter(station => Math.random() < 0.3) // 30% chance per station
            .forEach(station => {
            const ores = Object.keys(Constants.ORES);
            const ore = ores[Math.floor(Math.random() * ores.length)];
            const amount = Math.floor(Math.random() * 10) + 5;  // 5-15 units
            const reward = amount * (ore === 'Gold' ? 100 : ore === 'Copper' ? 50 : 25);
            const mission = new MiningMission(station, ore, amount, reward);
            this.availableMissions.push(mission);
        });
    };

    update = (delta) => {
        this.activeMissions.forEach(mission => {
            mission.update(delta);
            if (mission.completed) {
                const index = this.activeMissions.indexOf(mission);
                this.activeMissions.splice(index, 1);
                this.completedMissions.push(mission);
            }
        });
        return this;
    };

    draw = (x = 10, y = 110, width = 300) => {
        // Draw mission UI
        // TODO: should probably be conditional
        ctx.save();
        
        // Draw panel background
        // ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        // ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
        // ui.roundedRectExt(ctx, x, y, width, 400, 10);
        
        // Draw title
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Arial';
        let yOffset = y + 90;
        ctx.fillText('Missions', x + 20, yOffset);

        // Draw active missions
        ctx.font = '12px Arial';
        if (this.activeMissions.length === 0) {
            ctx.fillText('No active missions', x + 20, yOffset += 30);
        } else {
            this.activeMissions.forEach(mission => {
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.fillText(mission.description, x + 20, yOffset += 40);
                if (mission instanceof MiningMission && mission.canComplete()) {
                    ctx.fillStyle = 'yellow';
                    ctx.fillText(`can be completed`, x + 20, yOffset += 20);
                    if (player.docked) {
                        // TODO: only show this for the first/top mission
                        ctx.fillText(`(N to complete)`, x + 150, yOffset);
                    }
                }
                ctx.fillText(`Reward: ${mission.reward} credits`, x + 20, yOffset += 20);
            });
        }
        ctx.restore();
    };
}

class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }

    update = () => {
        this.x = canvas.width/2 - spaceship.pos.x;
        this.y = canvas.height/2 - spaceship.pos.y;
    };

    apply = () => {
        ctx.save();
        ctx.translate(this.x, this.y);
    };

    restore = () => {
        ctx.restore();
    };

    screenToWorld = (screenX, screenY) => {
        return new Vec(screenX - this.x, screenY - this.y);
    };
}

class Enemy extends Selectable {
    constructor() {
        super();
        this.vel = new Vec(Math.random() * 0.01 - 0.005, Math.random() * 0.01 - 0.005);
     }

    update = (delta) => {
        return this;
    };

    draw = () => {
        this.drawSelection();
    };
}

class Asteroid extends Selectable {
    constructor() {
        super();
        this.rotationSpeed = Math.random() * 0.0008;
        this.rotation = Math.random() * Math.PI * 2;
    }

    moveAway = () => {
        // TODO: check if the asteroid is too close to another asteroid
        // if so, move it away
        // also, check if the asteroid is too close to the player
        // if so, move it away
        // also, check if the asteroid is too close to the spaceship
        // if so, move it away
        // also, check if the asteroid is too close to the station
        // if so, move it away
        return this;
    };

    mine = () => {
        if (Math.random() < 0.5) { // 1 ore
            const amount = this.size * (1 + Math.random() * 0.2);
            return [{ type: this.randomOre(), amount }];
        } // 2 ores
        const amount = this.size * (1 + Math.random() * 0.2);
        const distribution = (Math.random()*60+20) / 100; // 20-80%
        return [{ type: this.randomOre(), amount: amount * distribution },
                { type: this.randomOre(), amount: amount * (1-distribution) }];
    }

    update = (delta) => {
        const rotation = this.rotation + this.rotationSpeed * delta;
        const clampedRotation = rotation % (Math.PI * 2);
        this.rotation = clampedRotation;
    };

    draw = () => {
        this.drawSelection();
        ui.drawIcon(Constants.SPRITE.ASTEROID, this.pos, false,
            system.asteroids.indexOf(this), false, 2, this.rotation);
    };

    randomOre = () => {
        const oreTypes = Object.keys(Constants.ORES).length;
        const randomIndex = Math.floor(Math.random() * oreTypes);
        return Object.keys(Constants.ORES)[randomIndex];
    }
}

class Spaceship {
    constructor(obj) {
        this.type = undefined; // string
        this.shield = undefined; // number
        this.maxShield = undefined; // number
        this.hull = undefined; // number
        this.maxHull = undefined; // number
        this.size = undefined; // number
        this.acceleration = undefined; // number
        this.vel = undefined; // Vec
        this.pos = undefined; // Vec
        this.target = undefined; // Vec
        this.miningRange = undefined; // number
        this.mode = undefined; // Constants.MOVE
        this.modules = undefined; // Module[]
        this.inventory = undefined; // Module[]

        Object.assign(this, obj);
        this.pos = new Vec(obj.pos.x, obj.pos.y);
        this.target = new Vec(obj.target.x, obj.target.y);
        this.vel = new Vec(obj.vel.x, obj.vel.y);
        // TODO: fix modules
    }

    update = (delta) => {
        this.move(delta);
        if (ui.k2down) this.mine();
        return this;
    };

    draw = () => {
        if(player.docked) return;
        ctx.save();
        // position correctly
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle + Math.PI/2.0);
        ctx.translate(-this.size*1.5, -this.size*1.5);
        // draw ship
        ui.drawIcon(Constants.SPRITE.SPACESHIP, { x: 0, y: 0 }, false, undefined, false, 1);
        // draw vector
        ctx.translate(this.size * 1.5, 0);
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.strokeStyle = 'lightblue';
        ctx.moveTo(0, 0);
        const speed = this.vel; //.length();
        ctx.lineTo(0, -speed * 10);
        ctx.stroke();
        ctx.restore();
        ctx.lineWidth = 1;
    };

    move = (delta) => {
        if (this.mode === Constants.MOVE.APPROACH) {
            const dir = this.target.sub(this.pos);
            this.vel += this.acceleration * delta;
            if (dir.length() > this.size) {
                const normalizedDir = dir.normalize();
                // "REAL" PHYSICS
                // const scaledDir = normalizedDir.scale(this.acceleration * delta);
                // const slow = scaledDir.clone().scale(-0.5);
                // this.vel = this.vel.add(scaledDir);
                // this.pos = this.pos.add(slow).add(this.vel);
                // this.angle = Math.atan2(this.vel.y, this.vel.x);

                // FAKE PHYSICS
                this.pos = this.pos.add(normalizedDir.scale(this.vel));
                this.angle = Math.atan2(normalizedDir.y, normalizedDir.x);
            } else {
                this.vel = 0; //.set(0, 0);
            };

        } else if (this.mode === Constants.MOVE.ORBIT) {
            
        }
    };

    mine = () => {
        // TODO: find() instead of forEach()
        // so ores.forEach is not nested
        // and so that you only mine one asteroid at a time
        system.asteroids.forEach((a, i) => {
            const dist = this.pos.sub(a.pos).length();
            const range = this.miningRange + a.size;
            if (dist > range) return;
            system.asteroids.splice(i, 1);
            const ores = a.mine(); // [{ type, amount }, ...]
            ores.forEach(ore => {
                const oreModule = this.inventory.find(m => m.name === ore.type);
                if (oreModule) {
                    oreModule.amount += ore.amount;
                } else {
                    const m = new Module(ore.type, Constants.SPRITE.MINE, ore.amount, 'kg');
                    this.inventory.push(m);
                }
            });  
        });
    };
}

class Module {
    constructor(name, sprite = undefined, amount = 1, unit = 'units') {
        this.name = name;
        this.sprite = sprite;
        this.amount = amount;
        this.unit = unit;
    }
}

class StarField {
    constructor() {
        this.stars = [];
        const createStarLayer = (count, speed, brightness) => {
            for (let i = 0; i < count; i++) {
                this.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,  // Size between 1-3
                    speed,
                    brightness
                });
            }
        };
        createStarLayer(100, 0.1, 0.2),  // Far layer (slow, dim)
        createStarLayer(50, 0.15, 0.4),  // Middle layer
        createStarLayer(25, 0.2, 0.6)   // Close layer (fast, bright)
    }

    update = (delta) => {
        this.stars.forEach(star => {
            // Move stars based on their layer speed
            star.x -= star.speed;
            star.y -= star.speed;
            // Wrap stars around the screen
            if (star.x < 0) star.x = canvas.width;
            if (star.x > canvas.width) star.x = 0;
            if (star.y < 0) star.y = canvas.height;
            if (star.y > canvas.height) star.y = 0;
        });
        return this;
    };
    
    draw = () => {
        if(player.docked) return;
        this.stars.forEach(star => {
            ctx.beginPath();
            ctx.fillStyle = `rgba(${system.color}, ${star.brightness})`;
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        });
    };
}

class UI {
    constructor() {
        // TODO: make buttons register themselves with callbacks
        // and implement it i the GameEventListener
        // { name (string), upper left (Vec), lower right (Vec), callback (()=>{}) } 
        this.buttons = [];
        this.selectables = [];
        this.fpsCount = 0;
        this.fpsTime = 0;
        this.fpsDisplay = 0;
        this.qDown = false;
        this.aDown = false;
        this.sDown = false;
        this.wDown = false;
        this.k1down = false;
        this.k2down = false;
        this.k3down = false;

        // TODO: why can I declare fields with and without this?
        // does that mean one is public and the other private?
        this.dialogWidth = 300;
        this.dialogHeight = 400;
        this.dialogX = canvas.width / 2 - this.dialogWidth / 2;
        this.dialogY = canvas.height / 2 - this.dialogHeight / 2;

        this.sprites = [];
        this.loadSprites();
    }

    update = (delta) => {
        this.fpsCount++;
        this.fpsTime += delta;
        if (this.fpsTime >= 1000) {

            this.fpsDisplay = this.fpsCount;
            this.fpsCount = 0;
            this.fpsTime = 0;
        }
        return this;
    };

    draw = () => {
        if (this.wDown) {
            this.drawShipDialog();
        } else if (this.eDown) {
            this.drawPilotDialog();
        } else if (this.dDown) {
            this.drawSettingsDialog();
        } else if (this.k1down) {
            this.drawWarpDialog();
        }
        this.drawFps();
        this.drawButtons();
        // draw system info
        // ui.drawPanel({ x: 0, y: 100 }, 100, 200);
        this.drawTexts([`system: ${system.name}`, `station: ${system.stations[0].name}`], { x: 10, y: 120 });
    };

    drawIcon = (spriteIndex, pos, selected = false, text = undefined, 
                     outline = true, scale = 1, rotation = 0) => {
        const size = 40*scale;
        if (!this.sprites[spriteIndex]) return;
        if (selected) ctx.globalAlpha = 0.5;
        if (rotation !== 0) {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(rotation);
            ctx.drawImage(this.sprites[spriteIndex], -size/2, -size/2, size, size);
            ctx.restore();

        } else {
            ctx.drawImage(this.sprites[spriteIndex], pos.x, pos.y, size, size);
        }
        if (outline) {
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.strokeRect(pos.x, pos.y, 40, 40);
        }
        if (text !== undefined) {
            ctx.font = '11px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(text, pos.x+1, pos.y+5);
            ctx.fillText(text, pos.x-1, pos.y+4);
            ctx.fillStyle = 'white';
            ctx.fillText(text, pos.x, pos.y+4);
        }
        ctx.globalAlpha = 1;
    };

    roundedRectExt = (x, y, width, height, radius) => {
        this.roundedRect(x, y, width, height, radius);
    }

    roundedRect = (x, y, width, height, radius) => {
        ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    };

    loadSprites = () => {
        const spriteSheet = new Image();
        // icons from:
        // https://game-icons.net/
        // https://icons8.com
        spriteSheet.src = 'icons.png';
        spriteSheet.onload = () => {
            const spriteWidth = 40;
            const spriteHeight = 40;
            const columns = spriteSheet.width / spriteWidth;
            const rows = spriteSheet.height / spriteHeight;
            
            // Create a temporary canvas to extract sprites
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = spriteWidth;
            tempCanvas.height = spriteHeight;

            // Extract each sprite
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns; col++) {
                    tempCtx.clearRect(0, 0, spriteWidth, spriteHeight);

                    // Draw the portion of the sprite sheet we want
                    tempCtx.drawImage(
                        spriteSheet,
                        col * spriteWidth,    // source x
                        row * spriteHeight,   // source y
                        spriteWidth,          // source width
                        spriteHeight,         // source height
                        0,                    // dest x
                        0,                    // dest y
                        spriteWidth,          // dest width
                        spriteHeight          // dest height
                    );
                    
                    // Convert to an image and store
                    const sprite = new Image();
                    sprite.src = tempCanvas.toDataURL();
                    this.sprites.push(sprite);
                }
            }
        };
    }

    drawWarpDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Warp to:', this.dialogWidth, yOffset, this.dialogX);
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        const keys = ['R', 'T'];
        for (let i = 0; i < system.connections.length; i++) {
            const c = system.connections[i];
            // TODO: use the draw text function instead.
            // and read up on what a method is vs. a function - what is a "member" in JS?
            ctx.fillText(`name: ${c.system.name}`, this.dialogX + 30, yOffset += 20);
            ctx.fillText(`dist: ${c.distance}`, this.dialogX + 30, yOffset += 20);
            ctx.fillText(`press ${keys[i]} to warp`, this.dialogX + 30, yOffset += 20);
            yOffset += 30
        }
    };

    drawPanel = (pos, w, h) => {
        ctx.setLineDash([]);
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(pos.x, pos.y, w, h);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(pos.x, pos.y, w, h);
    };

    drawTexts = (texts, pos, off = 30, hor = false, 
                 selected = -1, color = 'white') => {
        let lastLength = 0
        texts.forEach((text, i) => {
            const x = pos.x + (hor ? off * i + lastLength * 8 : 0);
            const y = pos.y + (hor ? 0 : off * i);
            if (i === selected) ctx.fillStyle = 'blue';
            else ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(text, x, y);
            lastLength += text.length;
        });
    };

    drawFps = () => {
        this.drawPanel({ x: 0, y: 0 }, 100, 50);
        this.drawTexts(['fps: ' + this.fpsDisplay], { x: 10, y: 30 });
    };

    drawHealthCircle = (radius, percentage, color) => {
        const thickness = 8;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
        ctx.lineWidth = thickness;
        ctx.arc(canvas.width / 2, canvas.height - 60, radius, 0, Math.PI * 2);
        ctx.stroke();
        if (percentage > 0) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            const startAngle = -0.5 * Math.PI;
            const endAngle = (-0.5 + 2 * percentage / 100) * Math.PI;
            ctx.arc(canvas.width / 2, canvas.height - 60, radius, startAngle, endAngle);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
    };

    // TODO: simplify and re-use code for the UI - there's too much
    // and it's too complicated
    drawButtons = () => {
        const shieldPercentage = spaceship.shield / spaceship.maxShield * 100;
        const hullPercentage = spaceship.hull / spaceship.maxHull * 100;
        this.drawHealthCircle(40, shieldPercentage, 'rgba(0, 150, 255, 0.8)');
        this.drawHealthCircle(30, hullPercentage, 'rgba(255, 150, 0, 0.8)');
        this.drawTexts(['shield', `${shieldPercentage}%`],
                    { x: canvas.width / 2 - 90, y: canvas.height - 80 }, 15);
        this.drawTexts(['hull', `${hullPercentage}%`], 
                    { x: canvas.width / 2 + 60, y: canvas.height - 80 }, 15);
        const off = 45;
        let i = 3;
        const i2pos = (i) => { return { x: canvas.width / 2 - off*i, y: canvas.height - 45}; };
        this.drawIcon(Constants.SPRITE.FLY_TO, i2pos(i++), this.qDown, 'Q');
        this.drawIcon(Constants.SPRITE.APPROACH, i2pos(i++), this.aDown, 'A');
        this.drawIcon(Constants.SPRITE.ORBIT, i2pos(i++), this.sDown, 'S');
        this.drawIcon(Constants.SPRITE.SHIP, i2pos(i++), this.wDown, 'W');
        this.drawIcon(Constants.SPRITE.PILOT, i2pos(i++), this.eDown, 'E');
        this.drawIcon(Constants.SPRITE.SETTINGS, i2pos(i++), this.dDown, 'D');
        i = -4;
        this.drawIcon(Constants.SPRITE.FIRE, i2pos(i++), this.k3down, '3');
        this.drawIcon(Constants.SPRITE.MINE, i2pos(i++), this.k2down, '2');
        this.drawIcon(Constants.SPRITE.WARP, i2pos(i++), this.k1down, '1');
    };

    drawPilotDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Pilot', this.dialogWidth, yOffset, this.dialogX);
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        ctx.fillText(`name: ${player.name}`, this.dialogX + 30, yOffset += 20);
        ctx.fillText(`name: ${player.name}`, this.dialogX + 30, yOffset += 20);
        ctx.fillText(`credits: ${player.credits}`, this.dialogX + 30, yOffset += 20);
    };

    drawSettingsDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Settings', this.dialogWidth, yOffset, this.dialogX);
        yOffset += 20;
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        ctx.fillText('Exit Now', this.dialogX + 30, yOffset);
    };

    drawShipDialog = () => {
        this.roundedRect(this.dialogX, this.dialogY, this.dialogWidth, this.dialogHeight, 10);
        let yOffset = this.dialogY;
        yOffset = this.drawSectionHeader('Equipped Modules', this.dialogWidth, yOffset, this.dialogX);
        yOffset = this.drawSectionItems(spaceship.modules, yOffset, this.dialogX);
        yOffset = this.drawSectionHeader('Inventory', this.dialogWidth, yOffset, this.dialogX);
        this.drawSectionItems(spaceship.inventory, yOffset, this.dialogX);
    };

    drawSectionHeader = (text, width, yOffset, x) => {
        yOffset += 20;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial';
        ctx.fillText(text, x + 20, yOffset += 20);
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
        ctx.moveTo(x + 10, yOffset += 20);
        ctx.lineTo(x + width - 10, yOffset);
        ctx.stroke();
        ctx.font = '14px Arial';
        return yOffset + 20;
    };

    drawSectionItems = (modules, yOffset, x) => {
        modules.forEach((module) => {
            const m = module;
            ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
            ctx.fillText(`${module.name}`, x + 30, yOffset);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
            const amount = module.amount > 1 ? module.amount.toFixed(2) : module.amount;
            ctx.fillText(`${amount} ${module.unit}`, x + 150, yOffset);
            yOffset += 20;
        });
        return yOffset;
    };
}

class GameEventListener {
    register = () => {
        canvas.addEventListener('keyup', this.keyUpListener);
        canvas.addEventListener('keydown', this.keyDownListener);
        canvas.addEventListener('click', this.clickListener);
    };

    keyUpListener = (event) => {
        if (!player || !spaceship) return;
        if (event.key === 'q') {
            ui.qDown = false;
        } else if (event.key === 'a') {
            ui.aDown = false;
        } else if (event.key === 's') {
            ui.sDown = false;
        } else if (event.key === '1') {
            ui.k1down = false;
        } else if (event.key === '2') {
            ui.k2down = false;
        } else if (event.key === '3') {
            ui.k3down = false;
        } else if (event.key === 'w') {
            ui.wDown = false;
        } else if (event.key === 'e') {
            ui.eDown = false;
        } else if (event.key === 'd') {
            ui.dDown = false;
        }
    };

    keyDownListener = (event) => {
        if (!player || !spaceship) return;
        const selected = ui.selectables.find(s => s.selected);
        // MENUS
        if (event.key === 'w') {
            ui.wDown = true;
        } else if (event.key === 'e') {
            ui.eDown = true;
        } else if (event.key === 'd') {
            ui.dDown = true;
        } else if (event.key === 'f') {
            system.handleDocking();
        } else if (event.key === 'm' && player.docked) {
            player.docked.acceptMission();
        } else if (event.key === 'n') {
            missionManager.activeMissions.find(m => m.canComplete())?.complete();
        } else if (event.key === 'r' && ui.k1down) {
            // TODO move this logic somewhere else and add loading bar
            system = system.connections[0].system;
            new Vec(canvas.width / 2, canvas.height / 2);
        } else if (event.key === 't' && ui.k1down && system.connections.length > 1) {
            system = system.connections[1].system;
            new Vec(canvas.width / 2, canvas.height / 2);
        }

        if (player.docked) return
        
        // MOVEMENT
        if (event.key === 'q') {
            if (ui.qDown) return;
            ui.qDown = true;
        } else if (event.key === 'a') {
            ui.aDown = true;
            if (selected) {
                spaceship.mode = Constants.MOVE.APPROACH;
                spaceship.target = selected.pos;
            } else {
                // console.log('no asteroid selected');
            }
        } else if (event.key === 's') {
            ui.sDown = true;
            if (selected) {
                spaceship.mode = Constants.MOVE.ORBIT;
                spaceship.target = selected.pos;
            } else {
                // console.log('no asteroid selected');
            }
        }
        
        // MODULES
        if (event.key === '1') {
            ui.k1down = true;
        } else if (event.key === '2') {
            ui.k2down = true;
        } else if (event.key === '3') {
            ui.k3down = true;
        }
    };

    clickListener = (event) => {
        if (!player || !spaceship) return;
        const clickPos = camera.screenToWorld(event.x, event.y);

        // fly-to
        if (ui.qDown) { 
            spaceship.target = clickPos;
            return;
        }
        // select one selectable
        let select = undefined;
        ui.selectables.forEach((selectable) => {
            const dist = clickPos.sub(selectable.pos).length();
            if (dist < selectable.size) {
                select = selectable;
            }
        });
        // de-select all other selectables
        if (select) {
            ui.selectables.forEach((selectable) => { selectable.selected = false; });
            select.selected = true;
        }

    };
}

class Vec {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    add = (v) => {
        return new Vec(
            this.x + v.x,
            this.y + v.y,
        );
    };

    sub = (v) => {
        return new Vec(
            this.x - v.x,
            this.y - v.y,
        );
    };

    scale = (n) => {
        return new Vec(
            this.x * n,
            this.y * n,
        );
    };

    length = () => {
        return Math.sqrt(
            this.x * this.x +
            this.y * this.y
        );
    };

    normalize = () => {
        const len = this.length();
        if (len === 0) return new Vec();
        return this.scale(1 / len);
    };

    dot = (v) => {
        return this.x * v.x + this.y * v.y;
    };

    cross = (v) => {
        return this.x * v.y - this.y * v.x;
    };

    toString = () => {
        return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
    };

    clone = () => {
        return new Vec(this.x, this.y);
    };

    set = (x, y) => {
        this.x = x;
        this.y = y;
    };
}

class Game {
    constructor() {
        this.lastDelta = 0;
    }

    gameLoop = (delta) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // TODO: login UI - move...
        if (!player || !spaceship){
            ui.roundedRect(ui.dialogX, ui.dialogY, ui.dialogWidth, ui.dialogHeight, 10);
            let yOffset = 100;
            yOffset = ui.drawSectionHeader('Logging in...', ui.dialogWidth, yOffset, ui.dialogX);
            ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
            ctx.fillText(`user: ${'bob'}`, this.dialogX + 30, yOffset += 20);
            ctx.fillText(`pass: ${'1234'}`, this.dialogX + 30, yOffset += 20);

            if (!server.loggingIn) {
                console.log('logging in');
                server.login('bob', '1234');
            }
            return requestAnimationFrame(this.gameLoop);
        }

        // TODO: move... draw the station UI
        // TODO: remove all the early returns from the draw methods. 
        // the individual draw methods should not
        // worry about whether to render. That is the jobs of the Game class.
        if (player.docked) {
            ctx.fillStyle = 'white';
            ctx.font = '22px Arial';
            let yOffset = 100;
            const text = (s) => {ctx.fillText(s, canvas.width / 2, yOffset += 30)};
            text('YOU ARE DOCKED! - (F to undock)');
            text('this is the station UI!');
            text('---')
            const mission = player.docked.missionToAccept();
            if (mission) {
                text('this is the next mission to accept: (M to accept)');
                text('---')
                text(mission.title);
                text(mission.description);
                text(`Reward: ${mission.reward} credits`);
                text('---')
            }
            missionManager.update().draw();
            return requestAnimationFrame(this.gameLoop);
        }

        const newDelta = delta - this.lastDelta;
        this.lastDelta = delta;
        starField.update(newDelta).draw();

        // start camera transformation
        camera.update();
        camera.apply();
        system.update(newDelta).draw();
        spaceship.update(newDelta).draw();
        // stop transformation
        camera.restore();

        missionManager.update(newDelta).draw();
        player.update(newDelta).draw();
        ui.update(newDelta).draw();

        requestAnimationFrame(this.gameLoop);
    };

    start = () => {
        // register event listeners
        new GameEventListener().register();

        // generate missions
        setInterval(() => {
            if (!player ||player.docked) return;
            missionManager.generateNewMissions();
        }, 30); // TODO: make greater - low for testing...

        // start game loop
        requestAnimationFrame(this.gameLoop);
    };
}

////////////
// FIELDS //
////////////

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const ui = new UI();
const server = new Server();
let system = server.loadSystem();
let player;
let spaceship;
const starField = new StarField();
const camera = new Camera();
const missionManager = new MissionManager();
new Game().start();

</script>
</body>
</html>

<!-- notes

check TODOs!

make small indicators for where stations and asteroids are in your current instance.
make some way of handling instances.
fix UI for warping
no gates. space is small instances that you can warp between.
usually at planets, moons, or structures in space.
move menu buttons to the left side. and make all buttons clickable.

first MISSIONS...
first mission. given a frigate.
we're under attack. please help.
take out this frigate by locking them up, flying to them, and firing your guns.

second mission: our buddies need help too.
kill three frigates. these frigates are equipped with short range weapons.
stay out of range of their weapons while just staying in range of yours.
kite as necessary and take them down.

third mission. it doesn't seem like there any way out of this alive.
too many ships are warping in and our ward drive is down.
let's go do fighting. after all, a good fight is what it's all about.

welcome back pilot. you have awoken in another clone.
here's how a station works. you have been given a new frigate and 
a choice between weapons. a few more fighting missions follow
explaining more mechanics and dropping some cool loot.

then comes crafting. there are 2 aspects. mining and manufactoring.
levels are trained in both.
as you kill and loot and sell, you get xp and credits.
xp has some inherent bonuses to the skills you level
and credits can be used to buy ships and components.
credits carry over between deaths.
-->
