<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="#" />
    <title>dawn</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: rgb(13, 13, 32);
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas tabindex="1" id="gameCanvas"></canvas>
    <script type="module">

        /////////////
        // CLASSES //
        /////////////

        const Constants = {
            MOVE: {
                APPROACH: 0,
                ORBIT: 1
            },
            SPRITE: {
                MINE: 0,
                PILOT: 1,
                SHIP: 2,
                FIRE: 3,
                FLY_TO: 4,
                ORBIT: 5,
                APPROACH: 6,
                SETTINGS: 7,
                WARP: 8
            }
        };


        function Node() {
            // FIELDS 

            this.children = [];

            // PUBLIC METHODS

            this.update = (delta) => {
                this.children.forEach(child => child.update(delta));
            };

            this.draw = () => {
                this.children.forEach(child => child.draw());
            };
        }

        function Player() {
            // EXTENDS NODE
            Node.call(this);

            // FIELDS 

            this.name = 'Bob';
            this.credits = 0;
            this.ore = 0;
        }

        function AsteroidField() {
            // EXTENDS NODE
            Node.call(this);

            // FIELDS 

            this.maxAsteroids = 5;
            this.asteroids = [];

            // PUBLIC METHODS

            this.update = (delta) => {
                if (this.asteroids.length < this.maxAsteroids) {
                    this.asteroids.push(new Asteroid());
                }
            };

            this.draw = () => {
                ctx.save();
                this.asteroids.forEach(a => a.draw());
                ctx.restore();
            };
        }


        function Asteroid() {
            // EXTENDS NODE
            Node.call(this);

            // FIELDS

            this.size = Math.random() * 20 + 30;
            this.points = [];
            this.pos = new Vec(Math.random() * (canvas.width-40) + 20, 
                               Math.random() * (canvas.height-40) + 20);
            this.rotationSpeed = Math.random() * 0.008;
            this.rotation = 0;
            this.selected = false;

            // PUBLIC METHODS

            this.update = () => {
                this.rotation = (this.rotation + this.rotationSpeed) % (Math.PI * 2);
            };

            this.draw = () => {
                ctx.save();
                ctx.setLineDash([]);
                ctx.lineWidth = 1;
                ctx.fillStyle = 'rgba(55, 55, 55, 1)';
                ctx.strokeStyle = 'rgba(85, 85, 85, 1)';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();

                // DEBUGGING! draw the index of the asteroid in the asteroid field
                ctx.save();
                ctx.fillStyle = 'white';
                ctx.font = '22px Arial';
                const asteroids = node.children.find(c => c instanceof AsteroidField).asteroids;
                ctx.fillText(asteroids.indexOf(this), this.pos.x, this.pos.y);
                ctx.restore();

                if (this.selected) {
                    // draw selection border
                    ctx.save();
                    ctx.beginPath();
                    ctx.setLineDash([10]);
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 3;
                    const off = this.size + 5;
                    ctx.moveTo(this.pos.x - off, this.pos.y - off);
                    ctx.lineTo(this.pos.x + off, this.pos.y - off);
                    ctx.lineTo(this.pos.x + off, this.pos.y + off);
                    ctx.lineTo(this.pos.x - off, this.pos.y + off);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();

                    // Reset canvas state after selection
                    ctx.setLineDash([]);
                    ctx.lineWidth = 1;

                    // draw asteroid info
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText('Asteroid size ' + this.size.toFixed(1), 
                                 this.pos.x - this.size, this.pos.y - this.size - 10);
                    ctx.restore();
                }
            };
        }

        function Spaceship() {
            // EXTENDS NODE
            Node.call(this);

            // FIELDS 

            this.type = 'frigate';
            this.shield = 50;
            this.maxShield = 80;
            this.hull = 30;
            this.maxHull = 50;
            this.size = 30;
            this.acceleration = 0.05;
            this.vel = new Vec(0, 0);
            this.pos = new Vec(canvas.width / 2, canvas.height / 2);
            this.target = this.pos.clone();
            this.miningRange = 50;
            this.mode = 'direct'; // 'direct' or 'orbit'

            // PUBLIC METHODS

            this.draw = () => {
                ctx.save();
                // position correctly
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle + Math.PI/2.0);
                ctx.translate(-this.size*1.5, -this.size*1.5);
                // draw ship
                ctx.drawImage(img, 0, 0);
                // draw vector
                ctx.translate(this.size * 1.5, 0);
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.strokeStyle = 'lightblue';
                ctx.moveTo(0, 0);
                const speed = this.vel.length();
                ctx.lineTo(0, -speed * 10);
                ctx.stroke();
                ctx.restore();
            };

            this.update = () => {
                move();
                const ui = node.children.find(c => c instanceof UI);
                if (ui.k2down) {
                    mine();
                }
            };

            // PRIVATE METHODS

            const img = new Image();
            img.src = 'SpaceShipSmall.png';

            const move = () => {
                if (this.mode === 'direct') {
                    const dir = this.target.sub(this.pos);
                    if (dir.length() > this.size) {
                        const normalizedDir = dir.normalize();
                        const scaledDir = normalizedDir.scale(this.acceleration);
                        this.vel = this.vel.add(scaledDir);
                        this.pos = this.pos.add(this.vel);
                        this.angle = Math.atan2(this.vel.y, this.vel.x);
                    } else {
                        this.vel.set(0, 0);
                    };
                } else if (this.mode === 'orbit') {
                    // implment orbit mode here     
                }
            };


            const mine = () => {
                const player = node.children.find(c => c instanceof Player);
                const asteroids = node.children.find(c => c instanceof AsteroidField).asteroids;
                asteroids.forEach((a, i) => {
                    const dist = this.pos.sub(a.pos).length();
                    const range = this.miningRange + a.size;
                    if (dist < range) {
                        asteroids.splice(i, 1);
                        player.ore += a.size * (1 + Math.random() * 0.2);
                        console.log('mining! player.ore: ' + player.ore);
                    }   
                });
            };
        }

        function UI() {
            // EXTENDS NODE
            Node.call(this);

            // FIELDS 

            this.fpsCount = 0;
            this.fpsTime = 0;
            this.fpsDisplay = 0;
            this.qDown = false;
            this.aDown = false;
            this.sDown = false;
            this.k1down = false;
            this.k2down = false;
            this.k3down = false;

            // PUBLIC METHODS

            this.update = (delta) => {
                this.fpsCount++;
                this.fpsTime += delta;
                if (this.fpsTime >= 1000) {
                    this.fpsDisplay = this.fpsCount;
                    this.fpsCount = 0;
                    this.fpsTime = 0;
                }
            };

            this.draw = () => {
                drawFps();
                drawMenu();
            }

            // PRIVATE METHODS
            const sprites = [];
            // Load the sprite sheet
            const spriteSheet = new Image();
            spriteSheet.src = 'icons.png';
            // Once the image loads, split it into sprites
            spriteSheet.onload = () => {
                const spriteWidth = 40;
                const spriteHeight = 40;
                const columns = spriteSheet.width / spriteWidth;
                const rows = spriteSheet.height / spriteHeight;
                
                // Create a temporary canvas to extract sprites
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = spriteWidth;
                tempCanvas.height = spriteHeight;
                
                // Extract each sprite
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < columns; col++) {
                        tempCtx.clearRect(0, 0, spriteWidth, spriteHeight);
                        
                        // Draw the portion of the sprite sheet we want
                        tempCtx.drawImage(
                            spriteSheet,
                            col * spriteWidth,    // source x
                            row * spriteHeight,   // source y
                            spriteWidth,          // source width
                            spriteHeight,         // source height
                            0,                    // dest x
                            0,                    // dest y
                            spriteWidth,          // dest width
                            spriteHeight          // dest height
                        );
                        
                        // Convert to an image and store
                        const sprite = new Image();
                        sprite.src = tempCanvas.toDataURL();
                        sprites.push(sprite);
                    }
                }
            };

            const drawPanel = (pos, w, h) => {
                ctx.setLineDash([]);
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(pos.x, pos.y, w, h);

                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(pos.x, pos.y, w, h);
            };

            const drawTexts = (texts, pos, off = 30, hor = false, selected = -1, color = 'white') => {
                let lastLength = 0
                texts.forEach((text, i) => {
                    const x = pos.x + (hor ? off * i + lastLength * 8 : 0);
                    const y = pos.y + (hor ? 0 : off * i);
                    if (i === selected) ctx.fillStyle = 'blue';
                    else ctx.fillStyle = color;
                    ctx.font = '14px Arial';
                    ctx.fillText(text, x, y);
                    lastLength += text.length;
                });
            };

            const drawIcon = (spriteIndex, pos, selected = false) => {
                if (!sprites[spriteIndex]) return;
                if (selected) ctx.globalAlpha = 0.5;
                ctx.drawImage(sprites[spriteIndex], pos.x, pos.y);
                ctx.globalAlpha = 1;
            };

            const drawFps = () => {
                // upper left panel
                drawPanel({ x: 0, y: 0 }, 100, 50);
                drawTexts(['fps: ' + this.fpsDisplay], { x: 10, y: 30 });
            };

            const drawHealthCircle = (radius, percentage, color) => {
                const thickness = 8;
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = thickness;
                ctx.arc(canvas.width / 2, canvas.height - 60, radius, 0, Math.PI * 2);
                ctx.stroke();
                if (percentage > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = thickness;
                    const startAngle = -0.5 * Math.PI;
                    const endAngle = (-0.5 + 2 * percentage / 100) * Math.PI;
                    ctx.arc(canvas.width / 2, canvas.height - 60, radius, startAngle, endAngle);
                    ctx.stroke();
                }
                ctx.restore();
            }

            const drawMenu = () => {
                // lower middle panel
                // settings cogwheel sprite - simple settings screen and EXIT NOW button.
                // pilot sprite - showing who you are and credits. number of times dead. some other stats?
                // SHIP sprite - meaning simple inventory and fitted ship modules.
                // FIX FPS!

                // draw thick circles, for shield (blue) and hull (red) - washed out / art deco
                // in the middle, and spread out the other buttons to either side.

                const spaceship = node.children.find(c => c instanceof Spaceship);
                const shieldPercentage = spaceship.shield / spaceship.maxShield * 100;
                const hullPercentage = spaceship.hull / spaceship.maxHull * 100;
                drawHealthCircle(40, shieldPercentage, 'rgba(0, 150, 255, 0.8)');
                drawHealthCircle(30, hullPercentage, 'rgba(255, 150, 0, 0.8)');
                drawTexts(['shield:', shieldPercentage],
                          { x: canvas.width / 2 - 90, y: canvas.height - 80 }, 15);
                drawTexts(['hull:', hullPercentage], 
                          { x: canvas.width / 2 + 60, y: canvas.height - 80 }, 15);


                const off = 45;
                let i = 3;
                const i2pos = (i) => { return { x: canvas.width / 2 - off*i, y: canvas.height - 40}; };
                drawIcon(Constants.SPRITE.FLY_TO, i2pos(i++), this.qDown);
                drawIcon(Constants.SPRITE.APPROACH, i2pos(i++), this.aDown);
                drawIcon(Constants.SPRITE.ORBIT, i2pos(i++), this.sDown);
                drawIcon(Constants.SPRITE.SHIP, i2pos(i++));
                drawIcon(Constants.SPRITE.PILOT, i2pos(i++));
                drawIcon(Constants.SPRITE.SETTINGS, i2pos(i++));

                i = -4;
                drawIcon(Constants.SPRITE.WARP, i2pos(i++), this.k1down);
                drawIcon(Constants.SPRITE.MINE, i2pos(i++), this.k2down);
                drawIcon(Constants.SPRITE.FIRE, i2pos(i++), this.k3down);

                // DEBUGGING - draw all the sprites
                // sprites.forEach((sprite, i) => {
                //     ctx.drawImage(sprite, 40*i, canvas.height / 2);
                // });
            };
        }


        function Vec(x = 0, y = 0) {
            this.x = x;
            this.y = y;

            this.add = (v) => {
                return new Vec(
                    this.x + v.x,
                    this.y + v.y,
                );
            };

            this.sub = (v) => {
                return new Vec(
                    this.x - v.x,
                    this.y - v.y,
                );
            };

            this.scale = (n) => {
                return new Vec(
                    this.x * n,
                    this.y * n,
                );
            };

            this.length = () => {
                return Math.sqrt(
                    this.x * this.x +
                    this.y * this.y
                );
            };

            this.normalize = () => {
                const len = this.length();
                if (len === 0) return new Vec();
                return this.scale(1 / len);
            };

            this.dot = (v) => {
                return this.x * v.x + this.y * v.y;
            };

            this.cross = (v) => {
                return this.x * v.y - this.y * v.x;
            };

            this.toString = () => {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
            };

            this.clone = () => {
                return new Vec(this.x, this.y);
            };

            this.set = (x, y) => {
                this.x = x;
                this.y = y;
            };
        }

        ////////////


        // FIELDS //
        ////////////

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const node = new Node();

        ///////////////
        // FUNCTIONS //
        ///////////////

        function initialSetup() {
            const asteroidField = new AsteroidField();
            const player = new Player();
            const spaceship = new Spaceship();
            const ui = new UI();
            node.children.push(asteroidField);
            node.children.push(player);
            node.children.push(spaceship);
            node.children.push(ui);

            canvas.addEventListener('keyup', (event) => {
                if (event.key === 'q') {
                    ui.qDown = false;
                } else if (event.key === 'a') {
                    ui.aDown = false;
                } else if (event.key === 's') {
                    ui.sDown = false;
                } else if (event.key === '1') {
                    ui.k1down = false;
                } else if (event.key === '2') {
                    ui.k2down = false;
                } else if (event.key === '3') {
                    ui.k3down = false;
                }
            });

            canvas.addEventListener('keydown', (event) => {
                const selected = asteroidField.asteroids.filter(a => a.selected);
                if (event.key === 'q') {
                    if (ui.qDown) return;
                    ui.qDown = true;
                } else if (event.key === 'a') {
                    ui.aDown = true;
                    if (selected.length > 0) {
                        spaceship.mode = 'direct';
                        spaceship.target = selected[0].pos;
                    } else {
                        console.log('no asteroid selected');
                    }
                } else if (event.key === 's') {
                    ui.sDown = true;
                    if (selected.length > 0) {
                        spaceship.mode = 'orbit';
                        spaceship.target = selected[0].pos;
                        // TODO
                    } else {
                        console.log('no asteroid selected');
                    }
                } else if (event.key === '1') {
                    ui.k1down = true;
                } else if (event.key === '2') {
                    ui.k2down = true;
                } else if (event.key === '3') {
                    ui.k3down = true;
                }
            });

            canvas.addEventListener('click', (event) => {
                console.log('clicked at ' + event.x + ', ' + event.y);
                let select = undefined;
                asteroidField.asteroids.forEach((a) => {
                    const clickPos = new Vec(event.x, event.y);
                    const dist = clickPos.sub(a.pos).length();
                    if (dist < a.size) {
                        console.log('selected asteroid at ' + a.pos.x + ', ' + a.pos.y);
                        select = a;
                    }

                    if (ui.qDown) { 
                        spaceship.target = clickPos;
                    }
                });
                if (select) {
                    asteroidField.asteroids.forEach((a) => { a.selected = false; });
                    select.selected = true;
                }
            });
        }

        function gameLoop(delta) {
            node.update(delta);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            node.draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        initialSetup();
        requestAnimationFrame(gameLoop);
    </script>

</body>

</html>

<!-- notes

first mission. given a frigate.
we're under attack. please help.
take out this frigate by locking them up, flying to them, and firing your guns.

second mission: our buddies need help too.
kill three frigates. these frigates are equipped with short range weapons.
stay out of range of their weapons while just staying in range of yours.
kite as necessary and take them down.

third mission. it doesn't seem like there any way out of this alive.
too many ships are warping in and our ward drive is down.
let's go do fighting. after all, a good fight is what it's all about.

welcome back pilot. you have awoken in another clone.
here's how a station works. you have been given a new frigate and 
a choice between weapons. a few more fighting missions follow
explaining more mechanics and dropping some cool loot.

then comes crafting. there are 2 aspects. mining and manufactoring.
levels are trained in both.
as you kill and loot and sell, you get xp and credits.
xp has some inherent bonuses to the skills you level
and credits can be used to buy ships and components.
credits carry over between deaths.

keep ship in the middle and move the screen instead.

move all the node.children logic into class initializer.

controls:
D = warp
some UI for warping?
no gates. space is small instances that you can warp between.
usually at planets, moons, or structures in space.
display these buttons as squares in UI.

ressing the button should show the button being pressed
by slowly highliting it.
make the UI nicer. see through layer

-->