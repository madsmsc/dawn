<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="#" />
    <title>dawn</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: rgb(13, 13, 32);
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas tabindex="1" id="gameCanvas"></canvas>
<script type="module">

/////////////
// CLASSES //
/////////////

const Constants = {
    MOVE: {
        APPROACH: 0,
        ORBIT: 1
    },
    SPRITE: {
        // icons
        MINE: 0,
        PILOT: 1,
        SHIP: 2,
        FIRE: 3,
        FLY_TO: 4,
        ORBIT: 5,
        APPROACH: 6,
        SETTINGS: 7,
        WARP: 8,
        // models
        ASTEROID: 9,
        SPACESHIP: 10
    }
};

function Player() {
    // FIELDS 
    this.name = 'Bob';
    this.credits = 0;

    // PUBLIC METHODS
    this.update = (delta) => {
        return this;
    };

    this.draw = () => {

    };
}

function Camera() {
    // FIELDS 
    this.x = 0;
    this.y = 0;

    this.update = () => {
        this.x = canvas.width/2 - spaceship.pos.x;
        this.y = canvas.height/2 - spaceship.pos.y;
    };

    this.apply = () => {
        ctx.save();
        ctx.translate(this.x, this.y);
    };

    this.restore = () => {
        ctx.restore();
    };

    this.screenToWorld = (screenX, screenY) => {
        return new Vec(screenX - this.x, screenY - this.y);
    };
}

function AsteroidField() {
    // FIELDS 
    this.maxAsteroids = 5;
    this.asteroids = [];

    // PUBLIC METHODS

    // TODO: only create asteroids that don't overlap with others
    // and find some asteroid asset/icon
    // should I only use icons to keep it simple?
    // also for the spaceship? probably... at least for now.
    this.update = (delta) => {
        if (this.asteroids.length < this.maxAsteroids) {
            this.asteroids.push(new Asteroid());
        }
        this.asteroids.forEach(a => a.update(delta));
        return this;
    };

    this.draw = () => {
        this.asteroids.forEach(a => a.draw());
    };
}


function Asteroid() {
    // FIELDS
    this.size = Math.random() * 20 + 30;
    this.points = [];
    this.pos = new Vec(Math.random() * (canvas.width-40) + 20, 
                        Math.random() * (canvas.height-40) + 20);
    this.rotationSpeed = Math.random() * 0.0008;
    this.rotation = Math.random() * Math.PI * 2;
    this.selected = false;

    // PUBLIC METHODS

    // introduce weights so some are rarer than others
    const TYPES = [ 'Iron', 'Ice', 'Silicon', 'Gold', 'Platinum', 'Titanium', 
                    'Uranium', 'Cobalt', 'Mithril', 'Adamantium'];

    this.mine = () => {
        if (Math.random() < 0.5) { // 1 ore
            const type = TYPES[Math.floor(Math.random() * TYPES.length)];
            const amount = this.size * (1 + Math.random() * 0.2);
            return [{ type, amount }];
        } // 2 ores
        const type1 = TYPES[Math.floor(Math.random() * TYPES.length)];
        const type2 = TYPES[Math.floor(Math.random() * TYPES.length)];
        const amount = this.size * (1 + Math.random() * 0.2);
        const distribution = (Math.random()*60+20) / 100; // 20-80%
        return [{ type: type1, amount: amount * distribution },
                { type: type2, amount: amount * (1-distribution) }];
    }

    this.update = (delta) => {
        const rotation = this.rotation + this.rotationSpeed * delta;
        const clampedRotation = rotation % (Math.PI * 2);
        this.rotation = clampedRotation;
    };

    this.draw = () => {
        ui.drawIcon(Constants.SPRITE.ASTEROID, this.pos, false,
            asteroidField.asteroids.indexOf(this), false, 2, this.rotation);
        if (this.selected) {

            // TODO: wrong line styling...
            ctx.setLineDash([10, 5]);
            ctx.fillStyle = 'green';
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            ctx.rect(this.pos.x - this.size, this.pos.y - this.size, this.size * 2, this.size * 2);
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('Asteroid size ' + this.size.toFixed(1), 
                            this.pos.x - this.size, this.pos.y - this.size - 10);
        }
    };
}

function Spaceship() {
    // FIELDS 
    this.type = 'frigate';
    this.shield = 50;
    this.maxShield = 80;
    this.hull = 30;
    this.maxHull = 50;
    this.size = 15;
    this.acceleration = 0.005;
    this.vel = 0; //new Vec(0, 0); // FAKING IT
    this.pos = new Vec(canvas.width / 2, canvas.height / 2);
    this.target = this.pos.clone();
    this.miningRange = 50;
    this.mode = Constants.MOVE.APPROACH;
    this.modules = [new Module('laser weapon', Constants.SPRITE.FIRE, 1, 'module'),
                    new Module('mining laser', Constants.SPRITE.MINE, 1, 'module'),
                    new Module('warp drive', Constants.SPRITE.WARP, 1, 'module')]
    this.inventory = [];

    // PUBLIC METHODS
    this.update = (delta) => {
        move(delta);
        if (ui.k2down) mine();
        return this;
    };

    this.draw = () => {
        ctx.save();
        // position correctly
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle + Math.PI/2.0);
        ctx.translate(-this.size*1.5, -this.size*1.5);
        // draw ship
        ui.drawIcon(Constants.SPRITE.SPACESHIP, { x: 0, y: 0 }, false, undefined, false, 1);
        // draw vector
        ctx.translate(this.size * 1.5, 0);
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.strokeStyle = 'lightblue';
        ctx.moveTo(0, 0);
        const speed = this.vel; //.length();
        ctx.lineTo(0, -speed * 10);
        ctx.stroke();
        ctx.restore();
        ctx.lineWidth = 1;
    };

    // PRIVATE METHODS
    const move = (delta) => {
        if (this.mode === Constants.MOVE.APPROACH) {
            const dir = this.target.sub(this.pos);
            if (dir.length() > this.size) {
                const normalizedDir = dir.normalize();
                // REAL PHYSICS
                // const scaledDir = normalizedDir.scale(this.acceleration * delta);
                // const slow = scaledDir.clone().scale(-0.5);
                // this.vel = this.vel.add(scaledDir);
                // this.pos = this.pos.add(slow).add(this.vel);
                // this.angle = Math.atan2(this.vel.y, this.vel.x);

                // FAKE PHYSICS
                this.vel += this.acceleration * delta;
                this.pos = this.pos.add(normalizedDir.scale(this.vel));
                this.angle = Math.atan2(normalizedDir.y, normalizedDir.x);
            } else {
                this.vel = 0; //.set(0, 0);
            };

        } else if (this.mode === Constants.MOVE.ORBIT) {
            // implment orbit mode here     
        }
    };

    const mine = () => {
        asteroidField.asteroids.forEach((a, i) => {
            const dist = this.pos.sub(a.pos).length();
            const range = this.miningRange + a.size;
            if (dist > range) return;
            asteroidField.asteroids.splice(i, 1);
            const ores = a.mine(); // [{ type, amount }, ...]
            ores.forEach(ore => {

                const oreModule = this.inventory.find(m => m.name === ore.type);
                if (oreModule) {
                    oreModule.amount += ore.amount;
                } else {
                    this.inventory.push(new Module(ore.type, Constants.SPRITE.MINE, ore.amount, 'kg'));
                }
            });  
        });
    };
}

function Module(name, sprite = undefined, amount = 1, unit = 'units') {
    // FIELDS
    this.name = name;
    this.sprite = sprite;
    this.amount = amount;
    this.unit = unit;
}

function StarField() {
    // FIELDS
    this.stars = [];

    // PUBLIC METHODS
    this.update = (delta) => {
        this.stars.forEach(star => {
            // Move stars based on their layer speed
            star.x -= star.speed;
            star.y -= star.speed;
            // Wrap stars around the screen
            if (star.x < 0) star.x = canvas.width;
            if (star.x > canvas.width) star.x = 0;
            if (star.y < 0) star.y = canvas.height;
            if (star.y > canvas.height) star.y = 0;
        });
        return this;
    };
    
    this.draw = () => {
        this.stars.forEach(star => {
            ctx.beginPath();
            ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        });
    };

    // PRIVATE METHODS
    const createStarLayer = (count, speed, brightness) => {
        for (let i = 0; i < count; i++) {
            this.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 1,  // Size between 1-3
                speed,
                brightness
            });

        }
    };

    // Create three layers of stars
    createStarLayer(100, 0.1, 0.2);  // Far layer (slow, dim)
    createStarLayer(50, 0.15, 0.4);   // Middle layer
    createStarLayer(25, 0.2, 0.6);   // Close layer (fast, bright)
}

function UI() {
    // FIELDS 
    this.fpsCount = 0;
    this.fpsTime = 0;
    this.fpsDisplay = 0;
    this.qDown = false;
    this.aDown = false;
    this.sDown = false;
    this.wDown = false;
    this.k1down = false;
    this.k2down = false;
    this.k3down = false;

    // PUBLIC METHODS
    this.update = (delta) => {
        this.fpsCount++;
        this.fpsTime += delta;
        if (this.fpsTime >= 1000) {
            this.fpsDisplay = this.fpsCount;
            this.fpsCount = 0;
            this.fpsTime = 0;
        }
        return this;
    };

    this.draw = () => {
        if (this.wDown) {
            drawShipDialog();
        } else if (this.eDown) {
            drawPilotDialog();
        } else if (this.dDown) {
            drawSettingsDialog();
        } else if (this.k1down) {
            drawWarpDialog();
        }
        drawFps();
        drawButtons();
    };

    this.drawIcon = (spriteIndex, pos, selected = false, text = undefined, 
                     outline = true, scale = 1, rotation = 0) => {
        const size = 40*scale;
        if (!sprites[spriteIndex]) return;
        if (selected) ctx.globalAlpha = 0.5;
        if (rotation !== 0) {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(rotation);
            ctx.drawImage(sprites[spriteIndex], -size/2, -size/2, size, size);
            ctx.restore();
        } else {
            ctx.drawImage(sprites[spriteIndex], pos.x, pos.y, size, size);
        }
        if (outline) {
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.strokeRect(pos.x, pos.y, 40, 40);
        }
        if (text !== undefined) {
            ctx.font = '11px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(text, pos.x+1, pos.y+5);
            ctx.fillText(text, pos.x-1, pos.y+4);
            ctx.fillStyle = 'white';
            ctx.fillText(text, pos.x, pos.y+4);
        }
        ctx.globalAlpha = 1;
    };

    // PRIVATE METHODS
    const sprites = [];

    const spriteSheet = new Image();
    // icons from:
    // https://game-icons.net/
    // https://icons8.com
    spriteSheet.src = 'icons.png';

    spriteSheet.onload = () => {
        const spriteWidth = 40;
        const spriteHeight = 40;
        const columns = spriteSheet.width / spriteWidth;
        const rows = spriteSheet.height / spriteHeight;
        
        // Create a temporary canvas to extract sprites
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = spriteWidth;
        tempCanvas.height = spriteHeight;

        // Extract each sprite
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < columns; col++) {
                tempCtx.clearRect(0, 0, spriteWidth, spriteHeight);

                // Draw the portion of the sprite sheet we want
                tempCtx.drawImage(
                    spriteSheet,
                    col * spriteWidth,    // source x
                    row * spriteHeight,   // source y
                    spriteWidth,          // source width
                    spriteHeight,         // source height
                    0,                    // dest x
                    0,                    // dest y
                    spriteWidth,          // dest width
                    spriteHeight          // dest height
                );
                
                // Convert to an image and store
                const sprite = new Image();
                sprite.src = tempCanvas.toDataURL();
                sprites.push(sprite);
            }
        }
    };

    const drawWarpDialog = () => {
        console.log('drawWarpDialog');
    };

    const drawPanel = (pos, w, h) => {
        ctx.setLineDash([]);
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(pos.x, pos.y, w, h);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(pos.x, pos.y, w, h);
    };

    const drawTexts = (texts, pos, off = 30, hor = false, selected = -1, color = 'white') => {
        let lastLength = 0
        texts.forEach((text, i) => {
            const x = pos.x + (hor ? off * i + lastLength * 8 : 0);
            const y = pos.y + (hor ? 0 : off * i);
            if (i === selected) ctx.fillStyle = 'blue';
            else ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(text, x, y);
            lastLength += text.length;
        });
    };

    const drawFps = () => {
        drawPanel({ x: 0, y: 0 }, 100, 50);
        drawTexts(['fps: ' + this.fpsDisplay], { x: 10, y: 30 });
    };

    const drawHealthCircle = (radius, percentage, color) => {
        const thickness = 8;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
        ctx.lineWidth = thickness;
        ctx.arc(canvas.width / 2, canvas.height - 60, radius, 0, Math.PI * 2);
        ctx.stroke();
        if (percentage > 0) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            const startAngle = -0.5 * Math.PI;
            const endAngle = (-0.5 + 2 * percentage / 100) * Math.PI;
            ctx.arc(canvas.width / 2, canvas.height - 60, radius, startAngle, endAngle);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
    };

    const drawButtons = () => {
        const shieldPercentage = spaceship.shield / spaceship.maxShield * 100;
        const hullPercentage = spaceship.hull / spaceship.maxHull * 100;
        drawHealthCircle(40, shieldPercentage, 'rgba(0, 150, 255, 0.8)');
        drawHealthCircle(30, hullPercentage, 'rgba(255, 150, 0, 0.8)');
        drawTexts(['shield', `${shieldPercentage}%`],
                    { x: canvas.width / 2 - 90, y: canvas.height - 80 }, 15);
        drawTexts(['hull', `${hullPercentage}%`], 
                    { x: canvas.width / 2 + 60, y: canvas.height - 80 }, 15);
        const off = 45;
        let i = 3;
        const i2pos = (i) => { return { x: canvas.width / 2 - off*i, y: canvas.height - 45}; };
        this.drawIcon(Constants.SPRITE.FLY_TO, i2pos(i++), this.qDown, 'Q');
        this.drawIcon(Constants.SPRITE.APPROACH, i2pos(i++), this.aDown, 'A');
        this.drawIcon(Constants.SPRITE.ORBIT, i2pos(i++), this.sDown, 'S');
        this.drawIcon(Constants.SPRITE.SHIP, i2pos(i++), this.wDown, 'W');
        this.drawIcon(Constants.SPRITE.PILOT, i2pos(i++), this.eDown, 'E');
        this.drawIcon(Constants.SPRITE.SETTINGS, i2pos(i++), this.dDown, 'D');
        i = -4;
        this.drawIcon(Constants.SPRITE.FIRE, i2pos(i++), this.k3down, '3');
        this.drawIcon(Constants.SPRITE.MINE, i2pos(i++), this.k2down, '2');
        this.drawIcon(Constants.SPRITE.WARP, i2pos(i++), this.k1down, '1');
    };

    const dialogWidth = 300;
    const dialogHeight = 400;
    const dialogX = canvas.width / 2 - dialogWidth / 2;
    const dialogY = canvas.height / 2 - dialogHeight / 2;

    function drawPilotDialog() {
        roundedRect(dialogX, dialogY, dialogWidth, dialogHeight, 10);
        let yOffset = dialogY;
        yOffset = drawSectionHeader('Pilot', dialogWidth, yOffset, dialogX);
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        ctx.fillText(`name: ${player.name}`, dialogX + 30, yOffset += 20);
        ctx.fillText(`credits: ${player.credits}`, dialogX + 30, yOffset += 20);
    };

    function drawSettingsDialog() {
        roundedRect(dialogX, dialogY, dialogWidth, dialogHeight, 10);
        let yOffset = dialogY;
        yOffset = drawSectionHeader('Settings', dialogWidth, yOffset, dialogX);
        yOffset += 20;
        ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
        ctx.fillText('Exit Now', dialogX + 30, yOffset);
    };

    function drawShipDialog() {
        roundedRect(dialogX, dialogY, dialogWidth, dialogHeight, 10);
        let yOffset = dialogY;
        yOffset = drawSectionHeader('Equipped Modules', dialogWidth, yOffset, dialogX);
        yOffset = drawSectionItems(spaceship.modules, yOffset, dialogX);
        yOffset = drawSectionHeader('Inventory', dialogWidth, yOffset, dialogX);
        drawSectionItems(spaceship.inventory, yOffset, dialogX);
    };


    function drawSectionHeader(text, width, yOffset, x) {
        yOffset += 20;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial';
        ctx.fillText(text, x + 20, yOffset += 20);
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
        ctx.moveTo(x + 10, yOffset += 20);
        ctx.lineTo(x + width - 10, yOffset);
        ctx.stroke();
        ctx.font = '14px Arial';
        return yOffset + 20;
    };

    function drawSectionItems(modules, yOffset, x) {
        modules.forEach((module, index) => {
            ctx.fillStyle = 'rgba(150, 150, 255, 0.8)';
            ctx.fillText(`${module.name}`, x + 30, yOffset);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
            const amount = module.amount > 1 ? module.amount.toFixed(2) : module.amount;
            ctx.fillText(`${amount} ${module.unit}`, x + 150, yOffset);
            yOffset += 20;
        });
        return yOffset;
    };

    function roundedRect(x, y, width, height, radius) {
        ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    };
}

function GameEventListener() {
    // PUBLIC METHODS
    this.register = () => {
        canvas.addEventListener('keyup', keyUpListener);
        canvas.addEventListener('keydown', keyDownListener);
        canvas.addEventListener('click', clickListener);

    };

    // PRIVATE METHODS
    const keyUpListener = (event) => {
        if (event.key === 'q') {
            ui.qDown = false;
        } else if (event.key === 'a') {
            ui.aDown = false;
        } else if (event.key === 's') {
            ui.sDown = false;
        } else if (event.key === '1') {
            ui.k1down = false;
        } else if (event.key === '2') {
            ui.k2down = false;
        } else if (event.key === '3') {
            ui.k3down = false;
        } else if (event.key === 'w') {
            ui.wDown = false;
        } else if (event.key === 'e') {
            ui.eDown = false;
        } else if (event.key === 'd') {
            ui.dDown = false;
        }
    };

    const keyDownListener = (event) => {
        const selected = asteroidField.asteroids.find(a => a.selected);
        if (event.key === 'w') {
            ui.wDown = true;
        } else if (event.key === 'e') {
            ui.eDown = true;
        } else if (event.key === 'd') {
            ui.dDown = true;
        } else if (event.key === 'q') {
            if (ui.qDown) return;
            ui.qDown = true;
        } else if (event.key === 'a') {
            ui.aDown = true;
            if (selected) {
                spaceship.mode = Constants.MOVE.APPROACH;
                spaceship.target = selected.pos;
            } else {
                console.log('no asteroid selected');
            }
        } else if (event.key === 's') {
            ui.sDown = true;
            if (selected) {
                spaceship.mode = Constants.MOVE.ORBIT;
                spaceship.target = selected.pos;
            } else {
                console.log('no asteroid selected');
            }
        } else if (event.key === '1') {
            ui.k1down = true;
        } else if (event.key === '2') {
            ui.k2down = true;
        } else if (event.key === '3') {
            ui.k3down = true;
        }
    };

    const clickListener = (event) => {
        let select = undefined;
        const clickPos = camera.screenToWorld(event.x, event.y);
        // fly-to
        if (ui.qDown) { 
            spaceship.target = clickPos;
            return;
        }
        // select asteroid
        asteroidField.asteroids.forEach((a) => {
            const dist = clickPos.sub(a.pos).length();
            if (dist < a.size) {
                select = a;
            }
        });
        // de-select asteroids
        if (select) {
            asteroidField.asteroids.forEach((a) => { a.selected = false; });
            select.selected = true;
        }
    };
}

function Vec(x = 0, y = 0) {
    // FIELDS
    this.x = x;
    this.y = y;

    // PUBLIC METHODS
    this.add = (v) => {
        return new Vec(
            this.x + v.x,
            this.y + v.y,
        );
    };

    this.sub = (v) => {
        return new Vec(
            this.x - v.x,
            this.y - v.y,
        );
    };

    this.scale = (n) => {
        return new Vec(
            this.x * n,
            this.y * n,
        );
    };

    this.length = () => {
        return Math.sqrt(
            this.x * this.x +
            this.y * this.y
        );
    };

    this.normalize = () => {
        const len = this.length();
        if (len === 0) return new Vec();
        return this.scale(1 / len);
    };

    this.dot = (v) => {
        return this.x * v.x + this.y * v.y;
    };

    this.cross = (v) => {
        return this.x * v.y - this.y * v.x;
    };

    this.toString = () => {
        return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
    };

    this.clone = () => {
        return new Vec(this.x, this.y);
    };

    this.set = (x, y) => {
        this.x = x;
        this.y = y;
    };
}

////////////////
// GAME LOGIC //
////////////////

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const starField = new StarField();
const asteroidField = new AsteroidField();
const player = new Player();
const spaceship = new Spaceship();
const ui = new UI();
const camera = new Camera();
new GameEventListener().register();
let lastDelta = 0;

const gameLoop = (delta) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const newDelta = delta - lastDelta;
    lastDelta = delta;
    // BEFORE camera transformation
    starField.update(newDelta).draw();

    camera.update();
    camera.apply();
    // camera transformation
    asteroidField.update(newDelta).draw();
    spaceship.update(newDelta).draw();
    camera.restore();

    // AFTER camera transformation
    player.update(newDelta).draw();
    ui.update(newDelta).draw();
    requestAnimationFrame(gameLoop);

};

requestAnimationFrame(gameLoop);

</script>
</body>
</html>

<!-- notes

first mission. given a frigate.
we're under attack. please help.
take out this frigate by locking them up, flying to them, and firing your guns.

second mission: our buddies need help too.
kill three frigates. these frigates are equipped with short range weapons.
stay out of range of their weapons while just staying in range of yours.
kite as necessary and take them down.

third mission. it doesn't seem like there any way out of this alive.
too many ships are warping in and our ward drive is down.
let's go do fighting. after all, a good fight is what it's all about.

welcome back pilot. you have awoken in another clone.
here's how a station works. you have been given a new frigate and 
a choice between weapons. a few more fighting missions follow
explaining more mechanics and dropping some cool loot.

then comes crafting. there are 2 aspects. mining and manufactoring.
levels are trained in both.
as you kill and loot and sell, you get xp and credits.
xp has some inherent bonuses to the skills you level
and credits can be used to buy ships and components.
credits carry over between deaths.

keep ship in the middle and move the screen instead.

move all the node.children logic into class initializer.

controls:
D = warp
some UI for warping?
no gates. space is small instances that you can warp between.
usually at planets, moons, or structures in space.
display these buttons as squares in UI.

ressing the button should show the button being pressed
by slowly highliting it.
make the UI nicer. see through layer

-->